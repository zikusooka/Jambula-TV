#!/bin/sh
# This script is used to create DVB-T and IPTV channels in TVHeadend using CLI.
# Use it after services for both have been generated
# Also used in forcing IPTV network to scan from the command line
#
# Jambula Labs @copyright 2020-2021 All rights reserved

# Variables
PROJECT_NAME=JambulaTV
PROJECT_SYSTEM_CONF_DIR=/etc/$PROJECT_NAME
PROJECT_FUNCTIONS_FILE=$PROJECT_SYSTEM_CONF_DIR/functions
PROJECT_DVBT_SETTINGS_FILE=$PROJECT_SYSTEM_CONF_DIR/dvbt-settings.cfg

# Source install functions
. $PROJECT_FUNCTIONS_FILE

# Source DVBT settings file
. $PROJECT_DVBT_SETTINGS_FILE

# Other variables
YOUTUBE_CMD="/usr/bin/jambulatv-youtube"
YOUTUBE_VARIABLES_TEMP_FILE=$(grep ^YOUTUBE_VARIABLES_TEMP_FILE $YOUTUBE_CMD | cut -d '=' -f2 | head -1 | awk {'print $1'} | sed 's/"//g')

# Email
EMAIL_ADDRESS_USER=$(grep -i EMAIL_TO_ADDRESS $EMAIL_CREDENTIALS_CONFIG | sed '/^#/d' | cut -d = -f2 | sed 's/"//g')

# Product serial number
SERIAL=$(grep -i Serial $PROJECT_RELEASE_FILE | cut -d : -f2)

# TVHeadend
TVHEADEND_WIRED_URL="http://${NETWORK_IP_ADDRESS}:${TVHEADEND_HTTP_PORT}"
TVHEADEND_WIFI_URL="http://${NETWORK_WIRELESS_HOTSPOT_IP}:${TVHEADEND_HTTP_PORT}"
TVHEADEND_DVBT_TUNER_NODE=/dev/dvb/adapter$DVBT_TUNER_NO
TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE=$TMPDIR/create_dvb_channels.sh
TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE=$TMPDIR/create_dvb_channel_tags.sh
TVHEADEND_PLAY_STREAM_URL="${TVHEADEND_BASE_URL}/play/stream"
TVHEADEND_IPTV_SOURCE_PLAYLIST=${PLAYLISTS_DIRECTORY}/${PLAYLISTS_IPTV_WORLD_M3U_FILE}
TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE=$TMPDIR/iptv_service_uuid.txt
TVHEADEND_IPTV_INFO_LOG_FILE=$TVHEADEND_IPTV_LOG_DIR/iptv-scan-info.$(date +%Y%m%d%H%M).log
TVHEADEND_IPTV_FAILED_LOG_FILE=$TVHEADEND_IPTV_LOG_DIR/iptv-scan-failed.$(date +%Y%m%d%H%M).log
TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE=$TMPDIR/create_iptv_channels.sh
TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE=$TMPDIR/create_iptv_channel_tags.sh
TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE=$TMPDIR/iptv_scanning_in_progress
TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE=$TMPDIR/iptv_mapping_in_progress

TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE=$TMPDIR/create_cctv_channels.sh
TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE=$TMPDIR/create_cctv_channel_tags.sh
TVHEADEND_CCTV_INFO_LOG_FILE=$TVHEADEND_IPTV_LOG_DIR/cctv-scan-info.$(date +%Y%m%d%H%M).log
TVHEADEND_CCTV_SERVICE_UUIDS_RAW_FILE=$TMPDIR/cctv_service_uuid.txt
TVHEADEND_JTV_HOME_SOURCE_PLAYLIST=${PLAYLISTS_DIRECTORY}/${PLAYLISTS_JTV_HOME_M3U_FILE}
TVHEADEND_JTV_HOME_CREATE_CHAN_TEMP_FILE=$TMPDIR/create_jtvhome_channels.sh
TVHEADEND_JTV_HOME_CREATE_CHAN_TAG_TEMP_FILE=$TMPDIR/create_jtvhome_channel_tags.sh
TVHEADEND_JTV_HOME_INFO_LOG_FILE=$TVHEADEND_IPTV_LOG_DIR/jtvhome-scan-info.$(date +%Y%m%d%H%M).log
TVHEADEND_JTV_HOME_FAILED_LOG_FILE=$TVHEADEND_IPTV_LOG_DIR/jtvhome-scan-failed.$(date +%Y%m%d%H%M).log
TVHEADEND_JTV_HOME_SERVICE_UUIDS_RAW_FILE=$TMPDIR/jtvhome_service_uuid.txt

TVHEADEND_PLAYLIST_4_WIRED_CLIENTS=$TMPDIR/LiveTV-Lan
TVHEADEND_PLAYLIST_4_WIFI_CLIENTS=$TMPDIR/LiveTV-WiFi

PLAYLISTS_PORT=MY_PLAYLISTS_PORT

IPTV_BUILDER_BASE_DIR=/opt/jambula-iptv-builder
IPTV_BUILDER_GROUPS_DIR=$IPTV_BUILDER_BASE_DIR/groups
IPTV_BUILDER_CHANNEL_VARIABLES_FILE=$TMPDIR/iptv_builder_channels_variables

TV_TYPE=$1
TV_TASK=$2

# Generate log file
DEBUG_LOG=no



###############
#  FUNCTIONS  #
###############
usage () {
# Device Name
if [ "x$TV_TYPE" = "x" ];
then
clear
echo "Usage:  ./`basename $0` [dvb|iptv|cctv|jtvhome|general]
"
exit 1
fi
}

usage_and_pre_start_general () {
if [[ "x$TV_TASK" = "x" ]];
then
clear
echo "Usage:  ./`basename $0` general [clients]
"
exit 1
fi
}

generate_debug_log () {
PARENT_COMMAND="$(ps -o comm= $PPID)"
cat >> $TVHEADEND_LOG_DIR/$(basename $0).log <<EOT

$(date +'%b %d %I:%M:%S') [$PARENT_COMMAND] Running '$(basename $0) $TV_TYPE $TV_TASK'
-----------------------------------------------------------------------------------------
EOT
# Start Logging
exec 2>> $PROJECT_SYSTEM_LOG_DIR/$(basename $0).log
}

check_if_in_use () {
CURRENT_PROFILES=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/status/subscriptions | jq -r '.entries[] | .profile' | sed 's:null::g')
CURRENT_CHANNELS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/status/subscriptions | jq -r '.entries[] | .channel' | sed 's:null::g')
#
# Check to see if TVH Server is being used i.e. Playing TV
if [ "x$CURRENT_CHANNELS" != "x" ] || [ "x$CURRENT_PROFILES" != "x" ];
then
TVHEADEND_SERVER_IS_USE=yes
fi
}

quit_if_in_use () {
if [[ "$TVHEADEND_SERVER_IS_USE" = "yes" ]];
then
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$TVHEADEND_SERVER_IN_USE_MESSAGE" text
# Print notification using OSD tool
print_notification "$TVHEADEND_SERVER_IN_USE_MESSAGE" osd
#
# Quit if TVH Server is being used
exit 1
fi
}

skip_if_in_use () {
if [[ "$TVHEADEND_SERVER_IS_USE" = "yes" ]];
then
continue
fi
}

restart_if_not_in_use () {
if [[ "$TVHEADEND_SERVER_IS_USE" != "yes" ]];
then
sudo systemctl restart tvheadend.service
fi
}

notify_tv_server_controller_initiated () {
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$TVHEADEND_SERVER_REFRESH_START_MESSAGE" text
# Print notification using OSD tool
print_notification "$TVHEADEND_SERVER_REFRESH_START_MESSAGE" osd
}

notify_tv_server_controller_completed () {
sleep 30
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$TVHEADEND_SERVER_REFRESH_STOP_MESSAGE" text
# Print notification using OSD tool
print_notification "$TVHEADEND_SERVER_REFRESH_STOP_MESSAGE" osd
}

log_file () {
# Create IPTV log directory if non existent
[ -d $TVHEADEND_IPTV_LOG_DIR ] || mkdir -p $TVHEADEND_IPTV_LOG_DIR
# Give it Multimedia user's permissions
sudo chown -R $MULTIMEDIA_USER:$MULTIMEDIA_USER $TVHEADEND_IPTV_LOG_DIR

# Date stamp log file
cat >> $TVHEADEND_IPTV_INFO_LOG_FILE <<EOT

###############################################################################
IPTV services scan performed on:  $(date)
###############################################################################

EOT
}

tvheadend_restart_server () {
# Give multimedia user permission to access tvheadend directories
sudo chown -R $MULTIMEDIA_USER:video $TVHEADEND_CONFIG_DIR
#
# Check to see if TVHeadend server is in use, restart if it is not for 
# all except: jtvhome
check_if_in_use 
#
if [[ "$TV_TYPE" = "jtvhome" ]];
then
skip_if_in_use 
else
restart_if_not_in_use
fi
}

pre_config () {
# Create channels directory, if non-existent
[ -d $TVHEADEND_CHANNELS_CONFIG_DIR ] || mkdir -p $TVHEADEND_CHANNELS_CONFIG_DIR
#
# Load IPTV Lists i.e. restart tvheadend
tvheadend_restart_server
}

post_config () {
# Restart TVHeadend for all tasks except for m3u, epg, icons,general)
[[ "$TV_TASK" = "m3u" || "$TV_TASK" = "epg" || "$TV_TASK" = "icons" || "$TV_TASK" = "clients" ]] || tvheadend_restart_server
# Remove IPTV builder channel variables file
[[ -e $IPTV_BUILDER_CHANNEL_VARIABLES_FILE ]] && sudo rm -f $IPTV_BUILDER_CHANNEL_VARIABLES_FILE
}

usage_and_pre_start_dvb () {
if [[ "x$TV_TASK" = "x" ]];
then
clear
echo "Usage:  ./`basename $0` dvb [scan|map|all|repair|epg|icons]
"
exit 1

# Don't proceed if TV_TASK is epg, icons)
elif [[ "$TV_TASK" = "m3u" || "$TV_TASK" = "epg" || "$TV_TASK" = "icons" ]];
then
# Notify when TV server controller process has been initiated
notify_tv_server_controller_initiated
# Break out
break

else
# Check to see if TVHeadend server is in use, quit if it is
check_if_in_use 
quit_if_in_use
#
# Notify when TV server controller process has been initiated
notify_tv_server_controller_initiated
fi
}

usage_and_pre_start_iptv () {
if [[ "x$TV_TASK" = "x" ]];
then
clear
echo "Usage:  ./`basename $0` iptv [scan|map|all|m3u|epg|icons|enable|disable]
"
exit 1

# Don't proceed if TV_TASK is m3u, epg, icons)
elif [[ "$TV_TASK" = "m3u" || "$TV_TASK" = "epg" || "$TV_TASK" = "icons" ]];
then
# Notify when TV server controller process has been initiated
notify_tv_server_controller_initiated
# Break out
break

else
# Check to see if TVHeadend server is in use, quit if it is
check_if_in_use 
quit_if_in_use
#
# Notify when TV server controller process has been initiated
notify_tv_server_controller_initiated
fi
}

usage_and_pre_start_cctv () {
if [ "x$TV_TASK" = "x" ];
then
clear
echo "Usage:  ./`basename $0` cctv [scan|map|all]
"
exit 1

else
# Check to see if TVHeadend server is in use, quit if it is
check_if_in_use
quit_if_in_use
#
# Notify when TV server controller process has been initiated
notify_tv_server_controller_initiated
fi
}

usage_and_pre_start_jtvhome () {
if [ "x$TV_TASK" = "x" ];
then
clear
echo "Usage:  ./`basename $0` jtvhome [scan|map|all]
"
exit 1

else
# Check to see if TVHeadend server is in use, quit if it is
check_if_in_use
quit_if_in_use
#
# Notify when TV server controller process has been initiated
notify_tv_server_controller_initiated
fi
}

email_failed_iptv_notice () {
# Email notice regarding failed IPTV streams
[[ -e "$TVHEADEND_IPTV_FAILED_LOG_FILE" ]] && \
	$EMAIL_VIA_GMAIL_TOOL $EMAIL_ADDRESS_ERRORS "[JambulaTV]: IPTV services failed" "The following IPTV streams are no longer working at the following JambulaTV user: Serial No. $SERIAL" $TVHEADEND_IPTV_FAILED_LOG_FILE
}

zap_dead_services () { 
# Find dead services and remove them 
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/removeunseen > /dev/null 2>&1
}

zap_dead_channels () { 
# Find dead channels and remove them before mapping
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] | select(.name | contains("name-not-set")).uuid' | while read DEAD_CHANNEL_UUID
do
rm -f $TVHEADEND_CHANNELS_CONFIG_DIR/$DEAD_CHANNEL_UUID
done

# Remove previously added channels that no longer have services associated to them i.e. Don't play anymore. 
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] |.name,.services,.uuid' | grep -A1 "\[\]" | grep -Ev "(--|\[\])" | while read DEAD_CHANNEL_UUID
do
rm -f $TVHEADEND_CHANNELS_CONFIG_DIR/$DEAD_CHANNEL_UUID
done

# Restart TVH server
tvheadend_restart_server
}

check_status_of_iptv_channels () {
# Restart tvheadend for previous changes to take effect
tvheadend_restart_server

# Create service UUIDs file if non-existent
if [[ ! -e $TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE ]];
then
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq -r '.entries[] | select(.text | contains("'"${TVHEADEND_IPTV_NETWORK_NAME}"'")).uuid' > $TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE
fi

# Cycle through IPTV service UUIDs
while read IPTV_SERVICE_UUID;
do

IPTV_CHANNEL_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] | select(.services[] | contains("'"$IPTV_SERVICE_UUID"'")) .uuid')
IPTV_CHANNEL_NAME=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] | select(.services[] | contains("'"$IPTV_SERVICE_UUID"'")) .name' | uniq)
IPTV_CHANNEL_URI="$TVHEADEND_PLAY_STREAM_URL/channel/$IPTV_CHANNEL_UUID"

# Skip if no channel exists for service 
[[ "x$IPTV_CHANNEL_UUID" = "x" || "x$IPTV_CHANNEL_NAME" = "x" ]] && continue

# Test and see if link is playable
logger -s -t $(basename $0) "Checking status of channel [$IPTV_CHANNEL_NAME]"
#
# Probe TV channel
$FFPROBE_CMD $FFPROBE_OPTS_GLOBAL $FFPROBE_OPTS_STREAMS "$IPTV_CHANNEL_URI" >> /dev/null 2>&1
FFPROBE_EXIT_STATUS=$?
#
# Remove TV channels that are no longer playable i.e. Not working
if [[ "$FFPROBE_EXIT_STATUS" != "0" ]] && [[ -f $TVHEADEND_CHANNELS_CONFIG_DIR/$IPTV_CHANNEL_UUID ]];
then
sudo rm -f $TVHEADEND_CHANNELS_CONFIG_DIR/$IPTV_CHANNEL_UUID
logger -s -t $(basename $0) "Removed non-working iptv channel [$IPTV_CHANNEL_NAME]"
fi

done < $TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE
}

get_tvheadend_last_channel_number () {
# DVB-T channels
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] | select(.name!="name-not-set") | .number'| sort -n | grep -e '^1$' -e '^2$' > /dev/null 2>&1
TVHEADEND_DVBT_CHANNELS_EXIST=$?
#
# Non-DVB-T channels
TVHEADEND_LAST_CHANNEL_NUMBER=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] | select(.name!="name-not-set") | .number'| sort -n | tail -1)
}

refresh_tvh_kodi_icons () {
# Notify of refresh of TV icons
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$KODI_REFRESH_TV_LOGOS_MESSAGE" text
# Print notification using OSD tool
print_notification "$KODI_REFRESH_TV_LOGOS_MESSAGE" osd
#
# Clean and Trigger imagecache in TVHeadend
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/imagecache/config/clean -d clean=1 > /dev/null 2>&1
#
# Refresh TV logos in kodi
$KODI_CONTROLLER_TOOL tv_picons_repair > /dev/null 2>&1
}

get_tvh_clients_connected () {
cat <<ET
The following client(s) are connected to the TV server:

ET
echo "CHANNEL-NAME:IP-ADDRESS:PLAYER-TYPE:OPERATING-SYSTEM" | column -t -s ':'

echo "-------------------------------------------------------"

INDEX=0
CHANNEL_NAME=initial
while [[ "$INDEX" -ge "0" && "x$CHANNEL_NAME" != "x" ]];
do
CHANNEL_NAME=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/status/subscriptions | jq -r ".entries [$INDEX] | select(.state == "'"Running"'") | .channel")
CLIENT_IP_ADDRESS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/status/subscriptions | jq -r ".entries [$INDEX] | select(.state == "'"Running"'") | .hostname")
CLIENT_PLAYER=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/status/subscriptions | jq -r ".entries [$INDEX] | select(.state == "'"Running"'") | .client" | awk '{print $1}')
#CLIENT_OS=$(/usr/bin/nmap -Pn -O --osscan-guess $CLIENT_IP_ADDRESS | awk -F': ' '/Running/ {print $2}')
#
# Print details of connected client
echo "$CHANNEL_NAME:$CLIENT_IP_ADDRESS:$CLIENT_PLAYER:$CLIENT_OS" | column -t -s ':'

let "INDEX = $INDEX + 1"
done
}

generate_tvh_playlists () {
for TVH_PLAYLIST in \
${TVHEADEND_PLAYLIST_4_WIFI_CLIENTS} \
${TVHEADEND_PLAYLIST_4_WIRED_CLIENTS}
do
# Remove previous playlist
[[ -e ${TVH_PLAYLIST}.m3u ]] && rm -f ${TVH_PLAYLIST}.m3u
[[ -e ${TVH_PLAYLIST}.xspf ]] && rm -f ${TVH_PLAYLIST}.xspf
#
# Fetch TVHeadend playlists
$CURL_CMD -o ${TVH_PLAYLIST}.m3u $CURL_OPTS $TVHEADEND_WIRED_URL/playlist/channels
#
# Convert playlists to XSPF format which is suitable for VLC clients
$PLAYLIST_M3U2XSPF_TOOL -f -i ${TVH_PLAYLIST}.m3u -o ${TVH_PLAYLIST}.xspf > /dev/null 2>&1
done
}

send_tvh_playlist_via_telegram () {
# Generate TVHeadend playlists for both Wireless and LAN clients 
generate_tvh_playlists
#
# Source notification strings
set_notifications
#
# Send Telegram message when only LAN playlist requested
if [[ "$1" = "wired" ]] && [[ -e ${TVHEADEND_PLAYLIST_4_WIRED_CLIENTS}.xspf ]];
then
sudo jambulatv-telegram SendMessage "$TVHEADEND_PLAYLIST_GENERATED_NOTIFICATION_MESSAGE"
sudo jambulatv-telegram sendFileDisk ${TVHEADEND_PLAYLIST_4_WIRED_CLIENTS}.xspf
# Print notifciation to stdout and systemd journal 
print_notification "$TVHEADEND_PLAYLIST_GENERATED_NOTIFICATION_MESSAGE" text
# Send Telegram message when only WiFi playlist requested
elif [[ "$1" = "wireless" ]] && [[ -e ${TVHEADEND_PLAYLIST_4_WIFI_CLIENTS}.xspf ]];
then
sudo jambulatv-telegram SendMessage "$TVHEADEND_PLAYLIST_GENERATED_NOTIFICATION_MESSAGE"
sudo jambulatv-telegram sendFileDisk ${TVHEADEND_PLAYLIST_4_WIFI_CLIENTS}.xspf
# Print notifciation to stdout and systemd journal 
print_notification "$TVHEADEND_PLAYLIST_GENERATED_NOTIFICATION_MESSAGE" text
# Send Telegram message when both WiFi and LAN playlists inferred
else
sudo jambulatv-telegram SendMessage "$TVHEADEND_PLAYLIST_GENERATED_NOTIFICATION_MESSAGE"
sudo jambulatv-telegram sendFileDisk ${TVHEADEND_PLAYLIST_4_WIFI_CLIENTS}.xspf
sudo jambulatv-telegram sendFileDisk ${TVHEADEND_PLAYLIST_4_WIRED_CLIENTS}.xspf
# Print notifciation to stdout and systemd journal 
print_notification "$TVHEADEND_PLAYLIST_GENERATED_NOTIFICATION_MESSAGE" text
fi
}



############
#  DVB-T2  #
############
#
dvb_refresh_epg_data () {
# Remove TVH EPG Database
[[ -e $TVHEADEND_CONFIG_DIR/epgdb.v3 ]] && rm -f $TVHEADEND_CONFIG_DIR/epgdb.v3
# Restart TVHeadend
sudo systemctl restart tvheadend.service
# Run OTA grabbers
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/epggrab/ota/trigger -d trigger=1 > /dev/null 2>&1
# Pause to allow EPG to be added
sleep 60
# Run generic EPG tool
$EPG_GENERIC_TVGUIDE_TOOL > /dev/null 2>&1
}

dvb_query_scan_status () {
TVH_DVBT_SCAN_STATUS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] |select(.network_uuid=="'"$TVHEADEND_DVBT_NETWORK_UUID"'")|.scan_state' | uniq)
}

dvb_scan_add_muxes () {
# Notify of Live TV scan
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_NETWORK_SCAN_STARTED_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_NETWORK_SCAN_STARTED_MESSAGE" osd
#
TVHEADEND_DVBT_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$DVBT_NETWORK_NAME"'") |.uuid')
#
# Force scan of DVB network
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/scan -d uuid=$TVHEADEND_DVBT_NETWORK_UUID > /dev/null 2>&1
#
dvb_query_scan_status > /dev/null 2>&1
while [[ "$TVH_DVBT_SCAN_STATUS" != "0" ]];
do
# Notify of waiting for services to be added
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_WAITING_4_SERVICES_ADD_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_WAITING_4_SERVICES_ADD_MESSAGE" osd

# Pause a few seconds to allow all services to be added before proceeding to mapping
# of channels
sleep 20
#
dvb_query_scan_status > /dev/null 2>&1
done
}

dvb_add_channel_tags () {
# Remove previous temp script file for creating DVB-T channel tags
[[ -e $TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE ]] && sudo rm -f $TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE 

# Add DVB-T channels tags - Free-To-Air, Local, etc.
for TAG_NAME in "Free-To-Air" "Local" 
do
TAG_EXISTS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'"$TAG_NAME"'") |.enabled' | sed 's:"::g' | head -1)
TAG_EXISTS_COUNT=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'"$TAG_NAME"'") |.enabled' | wc -l)

# Test for existence of channel tag and ensure no duplicates are created
if [[ "$TAG_EXISTS" != "true" || "$TAG_EXISTS_COUNT" = "0" ]];
then
# Add DVB-T channel tags creation command to temp file
cat >> $TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel tag to backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
	"enabled": true,
	"index": 0,
	"name": "$TAG_NAME",
	"internal": false,
	"private": false,
	"icon": "",
	"icon_public_url": "",
	"titled_icon": false,
	"comment": "$TAG_NAME Digital TV Channels ($DVBT_NETWORK_NAME)"
}'

EOT
)
))" $TVHEADEND_API_URL/channeltag/create > /dev/null 2>&1
#
# Notify - Channel Tag added
logger -s -t $(basename $0) "Added Channel Tag [$TAG_NAME]"

EOF
fi

done

# Create TV channel tags script
if [[ -e $TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE ]];
then
# Prepare create TV channel tags script
sed -i '1i #!/bin/sh' "$TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE"
chmod 755 $TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE
# Run script to create TV channel tags
$TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE
# Pause for a bit to allow TV channel tags to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE
fi
}

dvb_map_services_2_channels () {
# Notify of DVB-T network mapping start
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_CHANNEL_MAP_STARTED_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_CHANNEL_MAP_STARTED_MESSAGE" osd

# Remove dead channels
zap_dead_channels

# Remove dead services
zap_dead_services

# Remove previous temp script file for creating DVB-T channels
[[ -e $TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE ]] && sudo rm -f $TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE 
#
# Set starting channel number/digit
get_tvheadend_last_channel_number
# Query for last DVB-T channel numbers
if [[ "$TVHEADEND_DVBT_CHANNELS_EXIST" = "0" ]];
then
TVHEADEND_LAST_CHANNEL_NUMBER=$TVHEADEND_LAST_CHANNEL_NUMBER
else
TVHEADEND_LAST_CHANNEL_NUMBER=0
fi
#
let "TVHEADEND_DVB_FIRST_CHANNEL_NUMBER = $TVHEADEND_LAST_CHANNEL_NUMBER + 1"
DIGIT=$TVHEADEND_DVB_FIRST_CHANNEL_NUMBER
#
# Cycle through list of DVB-T2 services that were created
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/service/grid?limit=100000 | jq -r '.entries[] | select(.network=="'"$DVBT_NETWORK_NAME"'")|.svcname' | sort -u | while read LINE

do
CHANNEL_NUMBER=$DIGIT
CHANNEL_NAME="$LINE"
CHANNEL_LOGO=$(echo $CHANNEL_NAME | tr [:lower:] [:upper:]| sed 's: :_:g').png
CHANNEL_TAGS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000  | jq '.entries[] | select(.comment | contains("'"$DVBT_NETWORK_NAME"'")) |.uuid' | paste -s -d",")
SERVICES=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/service/grid?limit=100000 | jq '.entries[] | select(.svcname=="'"$CHANNEL_NAME"'")|.uuid')

# Count number of this DVB-T channel that exists
DVBT_CHANNEL_EXISTS_COUNT=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] | select (.name=="'"$CHANNEL_NAME"'") |.name' | wc -l)

# Test for existence of DVB-T channel - Don't add if channel already exists
[[ "$DVBT_CHANNEL_EXISTS_COUNT" = "0" ]] || break

# Add DVB-T channel creation command to temp file
cat >> $TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel to TVHeadend backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
  "bouquet": "",
  "tags": [
  $CHANNEL_TAGS
  ],
  "services": [
  $SERVICES
  ],
  "epg_running": -1,
  "dvr_pst_time": 0,
  "dvr_pre_time": 0,
  "epggrab": [],
  "epglimit": 0,
  "enabled": true,
  "autoname": false,
  "name": "$CHANNEL_NAME",
  "number": $CHANNEL_NUMBER,
  "icon": "file://$PROJECT_SYSTEM_SHARE_DIR/picons/$TV_MARKET/$CHANNEL_LOGO",
  "epgauto": true
}'

EOT
)
))" $TVHEADEND_API_URL/channel/create > /dev/null 2>&1
#
# Notify - Channel added
logger -s -t $(basename $0) "Found channel number.[$CHANNEL_NUMBER] [$CHANNEL_NAME]"

EOF
#
#
let "DIGIT = $CHANNEL_NUMBER + 1"
done

# Create DVB-T channels script
if [[ -e $TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE ]];
then
# Prepare create DVB-T channels script
sed -i '1i #!/bin/sh' "$TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE"
chmod 755 $TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE
# Run script to create DVB-T channels
$TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE
# Pause for a bit to allow DVB-T channels to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE
fi

# Notify of DVB-T network mapping complete
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_CHANNEL_MAP_COMPLETED_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_CHANNEL_MAP_COMPLETED_MESSAGE" osd
}

repair_dvb_tvheadend_network () {
# Quit if, there's already a process to reset or repair tvheadend
if [[ -e $TVHEADEND_REPAIR_IN_PROGRESS_TEMP_FILE ]] || \
	[[ -e $TVHEADEND_REPAIR_IN_PROGRESS_TEMP_FILE ]]
then
# Notify of termination of reset
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_NETWORK_REPAIR_TERMINATED" text
# Print notification using OSD tool
print_notification "$DVBT_NETWORK_REPAIR_TERMINATED" osd

# Quit
exit 0
fi

# Quit if TVHeadend is NOT running because of other process like CCTV being configured
systemctl -q is-active tvheadend.service || exit

# Notify start of DVB-T network repair process
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_NETWORK_REPAIR_STARTED_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_NETWORK_REPAIR_STARTED_MESSAGE" osd

# Add control file for other apps to know that TVHeadend Repair is in progress
[ -e $TVHEADEND_REPAIR_IN_PROGRESS_TEMP_FILE ] || \
touch $TVHEADEND_REPAIR_IN_PROGRESS_TEMP_FILE

# Remove corrupted DVB-T network config files if existent
if [[ -d $TVHEADEND_DVBT_NETWORK_CONFIG_DIR ]];
then
# Remove config directories with empty config files i.e. corrupted DVB-T networks
rm -rf $(find $TVHEADEND_DVBT_NETWORK_CONFIG_DIR -iname config -size 0 -type f -exec dirname {} \;)
fi

# Configure DVBT network afresh
dvb_functions_task_all

# Remove control file for other apps to know that TVHeadend Repair completed
[ -e $TVHEADEND_REPAIR_IN_PROGRESS_TEMP_FILE ] && \
sudo rm -f $TVHEADEND_REPAIR_IN_PROGRESS_TEMP_FILE
}

check_health_of_dvb_tvheadend_network () {
# Notify of DVB-T health status check
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_CHECK_HEALTH_STATUS_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_CHECK_HEALTH_STATUS_MESSAGE" osd

# See if DVBT network UUID exists
TVHEADEND_DVBT_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$DVBT_NETWORK_NAME"'") |.uuid')
#
# Set DVB-T matched to adapter variable
if [[ "x$TVHEADEND_DVBT_NETWORK_UUID" != "x" ]];
then
# Check if DVB network is correctly associated with the DVB-T2 tuner adapter
sudo grep -rli $TVHEADEND_DVBT_NETWORK_UUID $TVHEADEND_ADAPTERS_CONFIG_DIR > /dev/null 2>&1
DVBT_NETWORK_MATCHED_WITH_TUNER=$?
fi

# 1) If no DVB-T2 tuner was found
# -------------------------------
if [[ ! -e "$TVHEADEND_DVBT_TUNER_NODE" ]];
then
# Notify of DVB-T tuner missing
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_ADAPTER_NODE_MISSING_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_ADAPTER_NODE_MISSING_MESSAGE" osd

# Quit
exit 0


# 2) If DVBT Network was accidentally wiped out
# ---------------------------------------------
elif [[ "x$TVHEADEND_DVBT_NETWORK_UUID" = "x" ]];
then

# Notify of DVB-T network missing
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_NETWORK_MISSING_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_NETWORK_MISSING_MESSAGE" osd

# Start DVB-T network repair process
repair_dvb_tvheadend_network 


# 3) If DVB-T network is not associated with the DVB-T tuner adapter
# ------------------------------------------------------------------
elif [[ "$DVBT_NETWORK_MATCHED_WITH_TUNER" != "0" && \
	"x$TVHEADEND_DVBT_NETWORK_UUID" != "x" ]];
then
# Notify of DVB-T network not being associated to any tuner
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_NETWORK_NOT_ASSOCIATED_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_NETWORK_NOT_ASSOCIATED_MESSAGE" osd

# Delete this network and prepare to start afresh
$CURL_CMD $CURL_OPTS -d uuid="$TVHEADEND_DVBT_NETWORK_UUID" $TVHEADEND_API_URL/idnode/delete > /dev/null 2>&1

# Start DVB-T network repair process
repair_dvb_tvheadend_network 

else
# Notify of DVB-T health status is OK
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_HEALTH_STATUS_OK_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_HEALTH_STATUS_OK_MESSAGE" osd

# Quit
exit 0
fi
}


##########
#  IPTV  #
##########
#
iptv_quit_if_no_playlist_found () {
if [[ ! -e "${TVHEADEND_IPTV_SOURCE_PLAYLIST}" ]] && [[ "$TV_TASK" != "map" ]];
then
# Notify that playlist is missing
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$IPTV_MISSING_PLAYLIST_MESSAGE" text
# Print notification using OSD tool
print_notification "$IPTV_MISSING_PLAYLIST_MESSAGE" osd
# Quit
exit 0
fi
}

iptv_get_fresh_playlist () {
# Notify that playlist is going to be downloaded
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$IPTV_FETCH_PLAYLIST_MESSAGE" text
# Print notification using OSD tool
print_notification "$IPTV_FETCH_PLAYLIST_MESSAGE" osd

# Fetch fresh IPTV playlists file from remote FTP server
ftp_connect_get_file $(basename $JAMBULATV_FTP_SERVER_IPTV_DIR_NAME)/ $PLAYLISTS_IPTV_WORLD_M3U_FILE $TMPDIR/
#
# Add fresh IPTV m3u8 file to JambulaTV playlists directory
[ -s $TMPDIR/$PLAYLISTS_IPTV_WORLD_M3U_FILE ] && \
	rsync -qavz --delay-updates $TMPDIR/$PLAYLISTS_IPTV_WORLD_M3U_FILE $PLAYLISTS_DIRECTORY/
# Remove temp IPTV playlist file
[ -e $TMPDIR/$PLAYLISTS_IPTV_WORLD_M3U_FILE ] && rm -f $TMPDIR/$PLAYLISTS_IPTV_WORLD_M3U_FILE
}

iptv_download_epg_data () {
# Cycle through all desired TV guides: UK, US
for EPG_XMLTV_COUNTRY in UK US
do
# Source EPG XMLTV guide sources by country
epg_xmltv_guide_sources 

# Check the age of the EPG data file and set whether it is fresh or not
[[ -e "$EPG_XMLTV_GUIDE_FILE" && "$(date -d "now - $(stat -c "%Y" $EPG_XMLTV_GUIDE_FILE) seconds" +%s)" -lt "$EPG_XMLTV_GUIDE_FILE_AGE" ]] && TV_GUIDE_FILE_IS_FRESH=yes

# Download only if EPG data file is 3 days old or more since the XML file is huge ~50MB
if [[ "$TV_GUIDE_FILE_IS_FRESH" != "yes" ]];
then

# Notify of start of EPG data download
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$EPG_DATA_DOWNLOAD_START_MESSAGE" text
# Print notification using OSD tool
print_notification "$EPG_DATA_DOWNLOAD_START_MESSAGE" osd

# Remove previous TV guide if more than than three days
[[ -e $EPG_XMLTV_GUIDE_FILE ]] && rm -f $EPG_XMLTV_GUIDE_FILE
# Give multimedia user access to the log file
[[ -e $EPG_XMLTV_LOG_FILE ]] && \
	sudo chown -R $MULTIMEDIA_USER:$MULTIMEDIA_USER $EPG_XMLTV_LOG_FILE

# Add EPG downloaded date header to log file
cat >> $EPG_XMLTV_LOG_FILE <<EOT

###############################################################################
Electronic Program Guide (EPG) Information for:		$EPG_XMLTV_COUNTRY
###############################################################################
EOT

# Download the latest TV guide (EPG) from upstream providor
wget_download_file $EPG_XMLTV_GUIDE_FILE $EPG_XMLTV_GUIDE_URL -a $EPG_XMLTV_LOG_FILE

# Determine file format of downloaded tvguide
EPG_XMLTV_GUIDE_FILE_FORMAT=$(file -b $EPG_XMLTV_GUIDE_FILE | awk {'print $1'})

# If file is compressed, then decompress per type
case $EPG_XMLTV_GUIDE_FILE_FORMAT in
#
# Gzip
[Gg][Zz][Ii][Pp])
# Rename
mv -v ${EPG_XMLTV_GUIDE_FILE} ${EPG_XMLTV_GUIDE_FILE}.gz
# Decompress
gunzip -v ${EPG_XMLTV_GUIDE_FILE}.gz
;;
#
# Zip 
[Zz][Ii][Pp])
# Rename
mv -v ${EPG_XMLTV_GUIDE_FILE} ${EPG_XMLTV_GUIDE_FILE}.zip
# Decompress
unzip -v ${EPG_XMLTV_GUIDE_FILE}.zip
;;
#
# Bzip2
[Bb][Zz][Ii][Pp]2)
# Rename
mv -v ${EPG_XMLTV_GUIDE_FILE} ${EPG_XMLTV_GUIDE_FILE}.bzip2
# Decompress
bunzip2 -v ${EPG_XMLTV_GUIDE_FILE}.bzip2
;;
#
# XZ
[Xx][Zz])
# Rename
mv -v ${EPG_XMLTV_GUIDE_FILE} ${EPG_XMLTV_GUIDE_FILE}.xz
# Decompress
unxz -v ${EPG_XMLTV_GUIDE_FILE}.xz
;;
esac

fi

done
}

iptv_refresh_epg_data () {
# Run TVH internal EPG grabbers e.g. xmltv: tv_grab_combiner -> tv_grab_uk_bleb
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/epggrab/internal/rerun -d rerun=1 > /dev/null 2>&1

# Download latest EPG data from upstream XMLTV provider
iptv_download_epg_data

# Notify of refresh of EPG data
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$EPG_DATA_4_KODI_REFRESH_MESSAGE" text
# Print notification using OSD tool
print_notification "$EPG_DATA_4_KODI_REFRESH_MESSAGE" osd

# Get status of External XMLTV EPG module
EPG_XMLTV_EXTERNAL_STATUS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/epggrab/module/list | jq -r '.entries[] | select(.title == "External: XMLTV") | .status')
# Alert if External XMLTV is disabled
if [[ "$EPG_XMLTV_EXTERNAL_STATUS" != "epggrabmodEnabled" ]];
then
logger -s -t $(basename $0) "Please enable External XMLTV EPG module in TVHeadend"

else
# Cycle through all desired TV guides: UK, US
for EPG_XMLTV_COUNTRY in UK US
do
# Source EPG XMLTV guide sources by country
epg_xmltv_guide_sources 

# Pipe EPG data into TVHeadend XMLTV EPG grabber module
[[ -e $EPG_XMLTV_GUIDE_FILE ]] && cat $EPG_XMLTV_GUIDE_FILE | \
	sudo $SOCAT_CMD $SOCAT_OPTS - UNIX-CONNECT:$EPG_XMLTV_SOCKET
# Add XMLTV based grabber listings for UK if available
logger -s -t $(basename $0) "Added TV guide for [$EPG_XMLTV_COUNTRY] to TVHeadend EPG grabber"
done
fi
}

iptv_status_of_network_scan () {
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/status/subscriptions | jq -r '.entries [] | select(.service | contains("'"$TVHEADEND_IPTV_NETWORK_NAME"'")) |.state' | grep -i -e Testing -e Running > /dev/null 2>&1
IPTV_NETWORK_SCAN_IN_PROGRESS=$?
#
while [[ "$IPTV_NETWORK_SCAN_IN_PROGRESS" = "0" ]];
do

# Wait while scan of IPTV network takes place
logger -s -t $(basename $0) "Scan of [$TVHEADEND_IPTV_NETWORK_NAME] network is in progress, please be patient ..."
sleep 60
#
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/status/subscriptions | jq -r '.entries [] | select(.service | contains("'"$TVHEADEND_IPTV_NETWORK_NAME"'")) |.state' | grep -i -e Testing -e Running > /dev/null 2>&1
IPTV_NETWORK_SCAN_IN_PROGRESS=$?
done
}

iptv_scan_add_muxes () {
# Set Network UUID - Keep this here, not top
TVHEADEND_IPTV_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") | .uuid')
#
# Force scan of IPTV network
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/scan -d uuid=$TVHEADEND_IPTV_NETWORK_UUID > /dev/null 2>&1

# Check the status of IPTV network scan
iptv_status_of_network_scan
}

configure_iptv_network () {
# Set Network UUID - Keep this here, not top
TVHEADEND_IPTV_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") | .uuid')
#
# See IPTV network similar to what we want already exists
SIMILAR_IPTV_NETWORK_FOUND=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") |.networkname')
#
# Test for existing IPTV network
if [[ "x$TVHEADEND_IPTV_NETWORK_UUID" != "x" || "x$SIMILAR_IPTV_NETWORK_FOUND" != "x" ]];
then
# Notify of IPTV network already existing and proceed
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$TVHEADEND_IPTV_NETWORK_NAME $IPTV_NETWORK_EXISTS_MESSAGE" text
# Print notification using OSD tool
print_notification "$TVHEADEND_IPTV_NETWORK_NAME $IPTV_NETWORK_EXISTS_MESSAGE" osd

else
# Add IPTV network
iptv_tvheadend_network_add

fi

# Download the latest IPTV playlist
iptv_get_fresh_playlist

# Add Muxes i.e. Force scan using TVHeadend API
iptv_scan_add_muxes
}

enable_iptv_network () {
TVHEADEND_IPTV_NETWORK_STATE=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") |.enabled')
TVHEADEND_IPTV_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") | .uuid')
#
# Enable IPTV network
[[ "$TVHEADEND_IPTV_NETWORK_STATE" = "false" ]] && \
	sed -i 's/"enabled": false,/"enabled": true,/g' $TVHEADEND_IPTV_NETWORK_CONFIG_DIR/$TVHEADEND_IPTV_NETWORK_UUID/config
# Restart tvheadend for changes to take effect
tvheadend_restart_server
}

disable_iptv_network () {
TVHEADEND_IPTV_NETWORK_STATE=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") |.enabled')
TVHEADEND_IPTV_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") | .uuid')
#
# Disable IPTV network
[[ "$TVHEADEND_IPTV_NETWORK_STATE" = "true" ]] && \
	sed -i 's/"enabled": true,/"enabled": false,/g' $TVHEADEND_IPTV_NETWORK_CONFIG_DIR/$TVHEADEND_IPTV_NETWORK_UUID/config
# Restart tvheadend for changes to take effect
tvheadend_restart_server
}

iptv_test_stream () {
# Stream variables
MUX_URL="$TVHEADEND_PLAY_STREAM_URL/mux/$MUX_UUID"
PLAYLIST_URL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .iptv_url')
PLAYLIST_CATEGORY=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .iptv_tags' | head -1)
PLAYLIST_CHANNEL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .iptv_sname' | head -1)
PLAYLIST_PIPE_COMMAND="$(echo $PLAYLIST_URL | sed 's|pipe://||g')"
#
# Wait a bit, other wise last TV channel will not be added
sleep 1
#
# Add to log file
echo 2>&1 | tee -a $TVHEADEND_IPTV_INFO_LOG_FILE << EOF


*******************************************************************************
JambulaTV: Testing IPTV stream: [$SERVICE_NAME], please wait ...
*******************************************************************************

EOF
# Probe remote stream using ffprobe i.e. play mux briefly to add service
$FFPROBE_CMD $FFPROBE_OPTS_GLOBAL $FFPROBE_OPTS_STREAMS $MUX_URL >> $TVHEADEND_IPTV_INFO_LOG_FILE 2>&1 

# Check if service was added i.e. Remote Link works
SERVICE_ADDED=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .num_svc')

# Test for whether stream was working
if [ "$SERVICE_ADDED" != "1" ];
then
# Log failed streams
cat >> $TVHEADEND_IPTV_FAILED_LOG_FILE << STREAMLOG

*******************************************************************************
$PLAYLIST_CHANNEL ($PLAYLIST_CATEGORY)
*******************************************************************************

Link:	$PLAYLIST_URL

STREAMLOG
fi
}

iptv_scan_add_services () {
# timestamp log file
log_file
#
# Add control file for other apps to know that IPTV scan is in progress
[ -e $TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE ] || touch $TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE
#
# Remove dead services
zap_dead_services

# Notify of IPTV network scan start
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$IPTV_NETWORK_SCAN_STARTED_MESSAGE" text
# Print notification using OSD tool
print_notification "$IPTV_NETWORK_SCAN_STARTED_MESSAGE" osd

# Set Network UUID - Keep this here, not top
TVHEADEND_IPTV_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") | .uuid')
#
# ----------------------------------------------------------
# Cycle through all IPTV MUX IDs and test to create services
# ----------------------------------------------------------
#
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.network_uuid=="'"$TVHEADEND_IPTV_NETWORK_UUID"'") | .uuid' | while read MUX_UUID

do
# Do not play if we already have a service
SERVICE_ADDED=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .num_svc')
SERVICE_NAME=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .name' | sed "s:$PLAYLISTS_IPTV_WORLD_M3U_FILE - ::g" | sed "s:^-*::g")
# Pipe stream variables
PLAYLIST_URL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .iptv_url')
PLAYLIST_CHANNEL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .iptv_sname' | head -1)
PLAYLIST_PIPE_COMMAND="$(echo $PLAYLIST_URL | sed 's|pipe://||g')"
#
echo $PLAYLIST_URL | grep $PLAYLIST_PIPE_COMMAND > /dev/null 2>&1
IS_YPIPE=$?

# Add service if none existent. Force testing of Youtube pipes
# ............................................................
# SERVICE_ADDED=1 means service was found
# IS_YPIPE=0 means URL is a Youtube pipe
if [[ "$SERVICE_ADDED" != "1" || "$IS_YPIPE" = "0" ]];
then
# Play mux 
iptv_test_stream
fi

done

# Add Muxes i.e. Force scan using TVHeadend API
iptv_scan_add_muxes 

# Email failed IPTV streams
email_failed_iptv_notice

# Remove control file for other apps to know that IPTV scan completed
[ -e $TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE ] && sudo rm -f $TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE
}

get_channel_variables_using_iptv_builder () {
CHANNEL_NAME="$1"
#
# Remove previous IPTV builder channel variables file
[[ -e $IPTV_BUILDER_CHANNEL_VARIABLES_FILE ]] && sudo rm -f $IPTV_BUILDER_CHANNEL_VARIABLES_FILE

# Read each line in channel categories file, and extract logo name
grep -Ei "^${CHANNEL_NAME}[[:space:]]*\|" -d skip $IPTV_BUILDER_GROUPS_DIR/* | while read LINE
do
CHANNEL_EPG="$(echo $LINE | cut -d '|' -f5 | awk '{$1=$1}1')"
CHANNEL_NAME="$(echo $LINE | cut -d '|' -f4 | awk '{$1=$1}1')"
CHANNEL_LOGO="$(echo $LINE | cut -d '|' -f3 | awk '{$1=$1}1')"
CHANNEL_NUMBER="$(echo $LINE | cut -d '|' -f2 | awk '{$1=$1}1')"
#
# Create temp IPTV builder channel variables file
cat > $IPTV_BUILDER_CHANNEL_VARIABLES_FILE <<ET
CHANNEL_EPG="$CHANNEL_EPG"
CHANNEL_NAME="$CHANNEL_NAME"
CHANNEL_LOGO="$CHANNEL_LOGO"
CHANNEL_NUMBER="$CHANNEL_NUMBER"
ET

done
#
# Source IPTV builder channel variables file
. $IPTV_BUILDER_CHANNEL_VARIABLES_FILE
}

iptv_map_services_2_channels () {
# Quit if IPTV playlist file is missing
iptv_quit_if_no_playlist_found

# Add control file for other apps to know that IPTV map is in progress
[[ -e $TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE ]] || touch $TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE

# Notify of IPTV network mapping start
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$IPTV_CHANNEL_MAP_STARTED_MESSAGE" text
# Print notification using OSD tool
print_notification "$IPTV_CHANNEL_MAP_STARTED_MESSAGE" osd

# Remove dead channels
zap_dead_channels

# Create IPTV channels
# ....................
# Remove previous temp script file for creating IPTV channels
[[ -e $TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE ]] && sudo rm -f $TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE
# Remove previous temp service UUID raw file for IPTV services
[[ -e $TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE ]] && sudo rm -f $TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE
# Create service UUIDs file
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq -r '.entries[] | select(.text | contains("'"${TVHEADEND_IPTV_NETWORK_NAME}"'")).uuid' > $TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE
#
# Cycle through IPTV services
cat $TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE | while read SERVICE_UUID
do
CHANNEL_NAME=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$SERVICE_UUID"'") | .text' | sed "s:$TVHEADEND_IPTV_NETWORK_NAME/$PLAYLISTS_IPTV_WORLD_M3U_FILE - ::g" | cut -d / -f2- | sed "s:^-*::g")
# Extract channel number and logo from iptv group files
get_channel_variables_using_iptv_builder "${CHANNEL_NAME}"
#
CHANNEL_CATEGORY=$(grep -Ew "${CHANNEL_NAME}$" ${TVHEADEND_IPTV_SOURCE_PLAYLIST} | grep '#EXTINF' | cut -d , -f1 | awk {'print $NF'} | cut -d = -f2 | sed 's:"::g' | head -1)
CHANNEL_TAG=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/list?limit=100000 | jq -r '.entries[] | select(.val=="'"${CHANNEL_CATEGORY}"'") | .key')

# Check if channel already exists
EXISTING_CHANNEL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] | select(.name | contains("'"$CHANNEL_NAME"'")) |.name' | uniq)
#
# Don't add if channel already exists
if [[ "x$EXISTING_CHANNEL" != "x" || "x$CHANNEL_NUMBER" != "x" ]];
then
logger -s -t $(basename $0) "IPTV channel [$CHANNEL_NAME] already exists, skipping its addition ..."
continue
fi

# Play service URL using ffprobe i.e. Activate it to make it usable as a channel
SERVICE_URL="$TVHEADEND_PLAY_STREAM_URL/service/$SERVICE_UUID"

# Add IPTV channel creation command to temp file
cat >> $TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel to TVHeadend backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
	"enabled": true,
	"number": $CHANNEL_NUMBER,
	"icon": "file://$PROJECT_SYSTEM_ICONS_DIR/IPTV/$CHANNEL_LOGO",
	"epgauto": true,
	"dvr_pre_time": 0,
	"dvr_pst_time": 0,
	"epg_running": -1,
	"services": [
		"$SERVICE_UUID"
	],
	"tags": [
		"$CHANNEL_TAG"
	],
	"bouquet": ""
}'
EOT
)
))" $TVHEADEND_API_URL/channel/create > /dev/null 2>&1
#
# Notify - Channel added
logger -s -t $(basename $0) "Found channel number.[$CHANNEL_NUMBER] [$CHANNEL_NAME]"

EOF

done

# Create IPTV channels script
if [[ -e $TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE ]];
then
# Prepare create IPTV channels script
sed -i '1i #!/bin/sh' "$TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE"
chmod 755 $TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE
# Run script to create IPTV channels
$TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE
# Pause for a bit to allow IPTV channels to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE
fi

# Ensure there are no non-working i.e. dead channels left
check_status_of_iptv_channels

# Remove temp service UUID raw file for IPTV services
[[ -e $TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE ]] && sudo rm -f $TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE

# Notify of IPTV network mapping complete
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$IPTV_CHANNEL_MAP_COMPLETED_MESSAGE" text
# Print notification using OSD tool
print_notification "$IPTV_CHANNEL_MAP_COMPLETED_MESSAGE" osd

# Remove control file for other apps to know that IPTV map completed
[ -e $TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE ] && sudo rm -f $TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE
}

iptv_add_channel_tags () {
# Quit if IPTV playlist file is missing
iptv_quit_if_no_playlist_found

# Remove previous temp script file for creating IPTV channel tags
[[ -e $TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE ]] && sudo rm -f $TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE 

# Cycle through playlist m3u8 file for IPTV channel tag
cat ${TVHEADEND_IPTV_SOURCE_PLAYLIST} | grep '#EXTINF' | cut -d , -f1 | awk {'print $NF'} | cut -d = -f2 | sed 's:"::g' | sort -u | while read IPTV_CHANNEL
do
TAG_NAME="$IPTV_CHANNEL"
TAG_EXISTS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'"$TAG_NAME"'") |.enabled' | head -1)
TAG_EXISTS_COUNT=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'"$TAG_NAME"'") |.enabled' | wc -l)

# Test for existence of channel tag and ensure no duplicates are created
if [[ "$TAG_EXISTS" != "true" || "$TAG_EXISTS_COUNT" = "0" ]];
then
# Add IPTV channel tags creation command to temp file
cat >> $TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel tag to backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
	"enabled": true,
	"index": 0,
	"name": "$TAG_NAME",
	"internal": false,
	"private": false,
	"icon": "",
	"icon_public_url": "",
	"titled_icon": false,
	"comment": "IPTV $TAG_NAME Channels"
}'

EOT
)
))" $TVHEADEND_API_URL/channeltag/create > /dev/null 2>&1
#
# Notify - Channel Tag added
logger -s -t $(basename $0) "Added Channel Tag [$TAG_NAME]"

EOF
fi

done

# Create IPTV channel tags script
if [[ -e $TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE ]];
then
# Prepare create IPTV channel tags script
sed -i '1i #!/bin/sh' "$TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE"
chmod 755 $TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE
# Run script to create IPTV channel tags
$TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE
# Pause for a bit to allow IPTV channel tags to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE
fi
}


##########
#  CCTV  #
##########
#
configure_cctv_network () {
TVHEADEND_CCTV_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_CCTV_NETWORK_NAME"'") |.uuid')
# See CCTV network similar to what we want already exists
SIMILAR_CCTV_NETWORK_FOUND=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_CCTV_NETWORK_NAME"'") |.networkname')
#
# Test for existing CCTV network
if [[ "x$TVHEADEND_CCTV_NETWORK_UUID" != "x" || "x$SIMILAR_CCTV_NETWORK_FOUND" != "x" ]];
then
# Notify of CCTV network already existing and proceed
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$CCTV_NETWORK_EXISTS_MESSAGE" text
# Print notification using OSD tool
print_notification "$CCTV_NETWORK_EXISTS_MESSAGE" osd

else
# Add CCTV network
cctv_tvheadend_network_add
fi
}

cctv_scan_add_muxes () {
TVHEADEND_CCTV_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_CCTV_NETWORK_NAME"'") |.uuid')
# Force scan of CCTV network
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/scan -d uuid=$TVHEADEND_CCTV_NETWORK_UUID > /dev/null 2>&1
}

cctv_add_channel_tags () {
# Remove previous temp script file for creating CCTV channel tags
[[ -e $TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE ]] && sudo rm -f $TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE 

# Cycle through playlist m3u8 file for CCTV channel tag
cat ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_CCTV_LOCAL_M3U_FILE} | grep '#EXTINF' | cut -d , -f1 | awk {'print $NF'} | cut -d = -f2 | sed 's:"::g' | sort -u | while read CCTV_CHANNEL
do
TAG_NAME="$CCTV_CHANNEL"
TAG_EXISTS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'"$TAG_NAME"'") |.enabled' | head -1)
TAG_EXISTS_COUNT=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'"$TAG_NAME"'") |.enabled' | wc -l)

# Test for existence of channel tag and ensure no duplicates are created
if [[ "$TAG_EXISTS" != "true" || "$TAG_EXISTS_COUNT" = "0" ]];
then
# Add CCTV channel tags creation command to temp file
cat >> $TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel tag to backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
	"enabled": true,
	"index": 0,
	"name": "$TAG_NAME",
	"internal": false,
	"private": false,
	"icon": "",
	"titled_icon": false,
	"comment": "$TAG_NAME Channels"
}'

EOT
)
))" $TVHEADEND_API_URL/channeltag/create > /dev/null 2>&1
#
# Notify - Channel Tag added
logger -s -t $(basename $0) "Added Channel Tag [$TAG_NAME]"

EOF
fi

done

# Create CCTV channels script
if [[ -e $TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE ]];
then
# Prepare create CCTV channels script
sed -i '1i #!/bin/sh' "$TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE"
chmod 755 $TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE
# Run script to create CCTV channels
$TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE
# Pause for a bit to allow TV channels to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE
fi
}

cctv_map_services_2_channels () {
# Notify of CCTV network mapping start
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$CCTV_CHANNEL_MAP_STARTED_MESSAGE" text
# Print notification using OSD tool
print_notification "$CCTV_CHANNEL_MAP_STARTED_MESSAGE" osd

# Remove dead channels
zap_dead_channels

# Create CCTV channels
# ....................
# Remove previous temp script file for creating DVB channels
[[ -e $TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE ]] && sudo rm -f $TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE 
# Remove previous temp service UUID raw file for CCTV services
[[ -e $TVHEADEND_CCTV_SERVICE_UUIDS_RAW_FILE ]] && sudo rm -f $TVHEADEND_CCTV_SERVICE_UUIDS_RAW_FILE
# Create service UUIDs file
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq -r '.entries[] | select(.text | contains("'"${TVHEADEND_CCTV_NETWORK_NAME}"'")).uuid' > $TVHEADEND_CCTV_SERVICE_UUIDS_RAW_FILE
#
# Cycle through CCTV services
cat $TVHEADEND_CCTV_SERVICE_UUIDS_RAW_FILE | while read SERVICE_UUID
do
CHANNEL_NAME=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$SERVICE_UUID"'") | .text' | sed "s:$TVHEADEND_CCTV_NETWORK_NAME/$PLAYLISTS_CCTV_LOCAL_M3U_FILE - ::g"| cut -d / -f2-)
# Extract channel number from CCTV playlist
CHANNEL_NUMBER=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_CCTV_LOCAL_M3U_FILE} | grep '#EXTINF' | cut -d = -f5 | awk {'print $1'} | sed 's:"::g' | head -1)
CHANNEL_LOGO=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_CCTV_LOCAL_M3U_FILE} | grep '#EXTINF' | cut -d = -f4 | awk {'print $1'} | sed 's:"::g' | head -1)
CHANNEL_CATEGORY=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_CCTV_LOCAL_M3U_FILE} | grep '#EXTINF' | cut -d , -f1 | awk {'print $NF'} | cut -d = -f2 | sed 's:"::g' | head -1)
CHANNEL_TAG=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/list?limit=100000 | jq -r '.entries[] | select(.val=="'"${CHANNEL_CATEGORY}"'") | .key')

# Check if channel already exists
EXISTING_CHANNEL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] | select(.name | contains("'"$CHANNEL_NAME"'")) |.name' | uniq)
#
# Don't add if channel already exists
[[ "x$EXISTING_CHANNEL"  = "x" ]] || continue

# Play service URL using ffprobe i.e. Activate it to make it usable as a channel
SERVICE_URL="$TVHEADEND_PLAY_STREAM_URL/service/$SERVICE_UUID"

# Probe remote stream using ffprobe i.e. play mux briefly to add service
$FFPROBE_CMD $FFPROBE_OPTS_GLOBAL $FFPROBE_OPTS_STREAMS $SERVICE_URL >> $TVHEADEND_CCTV_INFO_LOG_FILE 2>&1

# Add cctv channel creation command to temp file
cat >> $TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel to TVHeadend backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
	"enabled": true,
	"number": $CHANNEL_NUMBER,
	"icon": "file://$PROJECT_SYSTEM_ICONS_DIR/CCTV/$CHANNEL_LOGO",
	"epgauto": true,
	"dvr_pre_time": 0,
	"dvr_pst_time": 0,
	"epg_running": -1,
	"services": [
		"$SERVICE_UUID"
	],
	"tags": [
		"$CHANNEL_TAG"
	],
	"bouquet": ""
}'
EOT
)
))" $TVHEADEND_API_URL/channel/create > /dev/null 2>&1
#
# Notify - Channel added
logger -s -t $(basename $0) "Found channel number.[$CHANNEL_NUMBER] [$CHANNEL_NAME]"

EOF

done

# Create CCTV channels script
if [[ -e $TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE ]];
then
# Prepare create CCTV channels script
sed -i '1i #!/bin/sh' "$TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE"
chmod 755 $TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE
# Run script to create CCTV channels
$TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE
# Pause for a bit to allow CCTV channels to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE
fi

# Remove temp service UUID raw file for CCTV services
[[ -e $TVHEADEND_CCTV_SERVICE_UUIDS_RAW_FILE ]] && sudo rm -f $TVHEADEND_CCTV_SERVICE_UUIDS_RAW_FILE

# Notify of CCTV network mapping complete
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$CCTV_CHANNEL_MAP_COMPLETED_MESSAGE" text
# Print notification using OSD tool
print_notification "$CCTV_CHANNEL_MAP_COMPLETED_MESSAGE" osd
}


##############
#  JTV HOME  #
##############
jtvhome_quit_if_no_playlist_found () {
if [[ ! -e "${TVHEADEND_JTV_HOME_SOURCE_PLAYLIST}" ]];
then
# Notify that playlist is missing
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$JTV_HOME_MISSING_PLAYLIST_MESSAGE" text
# Print notification using OSD tool
print_notification "$JTV_HOME_MISSING_PLAYLIST_MESSAGE" osd
# Quit
exit 0
fi
}

configure_jtvhome_network () {
TVHEADEND_JTV_HOME_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_JTV_HOME_NETWORK_NAME"'") |.uuid')
# See JTV Home network similar to what we want already exists
SIMILAR_JTV_HOME_NETWORK_FOUND=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_JTV_HOME_NETWORK_NAME"'") |.networkname')
#
# Test for existing JTV Home network
if [[ "x$TVHEADEND_JTV_HOME_NETWORK_UUID" != "x" || "x$SIMILAR_JTV_HOME_NETWORK_FOUND" != "x" ]];
then
# Notify of JTV Home network already existing and proceed
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$JTV_HOME_NETWORK_EXISTS_MESSAGE" text
# Print notification using OSD tool
print_notification "$JTV_HOME_NETWORK_EXISTS_MESSAGE" osd

else
# Add JTV Home network
jtvhome_tvheadend_network_add
fi
}

jtvhome_scan_add_muxes () {
# Set Network UUID - Keep this here, not top
TVHEADEND_JTV_HOME_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_JTV_HOME_NETWORK_NAME"'") | .uuid')
#
# Force scan of IPTV network
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/scan -d uuid=$TVHEADEND_JTV_HOME_NETWORK_UUID > /dev/null 2>&1
}

jtvhome_add_channel_tags () {
# Remove previous temp script file for creating JTV Home channel tags
[[ -e $TVHEADEND_JTV_HOME_CREATE_CHAN_TAG_TEMP_FILE ]] && sudo rm -f $TVHEADEND_JTV_HOME_CREATE_CHAN_TAG_TEMP_FILE 

# Cycle through playlist m3u8 file for JTV Home channel tag
grep -oP "(?<=tvh-tags=\").+?(?=\")" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_JTV_HOME_M3U_FILE} | sort -u | while read JTV_HOME_CHANNEL_TAG
do
TAG_NAME="$JTV_HOME_CHANNEL_TAG"
TAG_EXISTS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'"$TAG_NAME"'") |.enabled' | head -1)
TAG_EXISTS_COUNT=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'"$TAG_NAME"'") |.enabled' | wc -l)

# Test for existence of channel tag and ensure no duplicates are created
if [[ "$TAG_EXISTS" != "true" || "$TAG_EXISTS_COUNT" = "0" ]];
then
# Add JTV Home channel tags creation command to temp file
cat >> $TVHEADEND_JTV_HOME_CREATE_CHAN_TAG_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel tag to backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
	"enabled": true,
	"index": 0,
	"name": "$TAG_NAME",
	"internal": false,
	"private": false,
	"icon": "",
	"titled_icon": false,
	"comment": "Local RTMP/HLS based TV Channels"
}'

EOT
)
))" $TVHEADEND_API_URL/channeltag/create > /dev/null 2>&1
#
# Notify - Channel Tag added
logger -s -t $(basename $0) "Added Channel Tag [$TAG_NAME]"

EOF
fi

done

# Create JTV Home channels script
if [[ -e $TVHEADEND_JTV_HOME_CREATE_CHAN_TAG_TEMP_FILE ]];
then
# Prepare create JTV Home channels script
sed -i '1i #!/bin/sh' "$TVHEADEND_JTV_HOME_CREATE_CHAN_TAG_TEMP_FILE"
chmod 755 $TVHEADEND_JTV_HOME_CREATE_CHAN_TAG_TEMP_FILE
# Run script to create JTV Home channels
$TVHEADEND_JTV_HOME_CREATE_CHAN_TAG_TEMP_FILE
# Pause for a bit to allow TV channels to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_JTV_HOME_CREATE_CHAN_TAG_TEMP_FILE
fi
}

jtvhome_rtmp_streaming_start () {
# Remove previous or any existing all streams temp file
[[ -e $RTMP_HLS_ALL_STREAMS_FILE ]] && sudo rm $RTMP_HLS_ALL_STREAMS_FILE
# Create temporary file listing all JTV channels to be streamed via RTMP/HLS
for JTV_CHANNEL in $(grep http $PLAYLISTS_DIRECTORY/$PLAYLISTS_JTV_HOME_M3U_FILE | cut -d '/' -f4 | cut -d '.' -f1);
do
echo -n "[f=flv]$RTMP_HLS_URL/$JTV_CHANNEL | " >> $RTMP_HLS_ALL_STREAMS_FILE
done 
# Clean up temp file
sed -i "s:[|][[:space:]]*$::" $RTMP_HLS_ALL_STREAMS_FILE
# Stream all JTV channels
$FFMPEG_CMD $FFMPEG_OPTS -fflags $FFMPEG_FFLAGS -flags $FFMPEG_FLAGS -re -i $RTMP_HLS_INPUT -codec copy -tune zerolatency -strict experimental -f tee -map 0:v -map 0:a "$(cat $RTMP_HLS_ALL_STREAMS_FILE)" &
}

jtvhome_rtmp_streaming_stop () {
FFMPEG_PID=$(ps u | awk '/[f]fmpeg/ {print $2}')
if [[ "x$FFMPEG_PID" != "x" ]];
then
kill $FFMPEG_PID || kill -9 $FFMPEG_PID
# Remove all streams temp file
[[ -e $RTMP_HLS_ALL_STREAMS_FILE ]] && sudo rm $RTMP_HLS_ALL_STREAMS_FILE
fi
}

jtvhome_test_stream () {
# Stream variables
MUX_URL="$TVHEADEND_PLAY_STREAM_URL/mux/$MUX_UUID"
PLAYLIST_URL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .iptv_url')
PLAYLIST_CHANNEL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .iptv_sname' | head -1)
#
# Wait a bit, other wise last TV channel will not be added
sleep 1
#
# Add service if none existent
# ............................
# SERVICE_ADDED=1 means service was found
if [[ "$SERVICE_ADDED" != "1" ]];
then
# Add to log file
echo 2>&1 | tee -a $TVHEADEND_JTV_HOME_INFO_LOG_FILE << EOF


*******************************************************************************
JambulaTV: Testing JTV Home stream: [$PLAYLIST_CHANNEL], please wait ...
*******************************************************************************

EOF
# Probe stream using ffprobe i.e. play mux briefly to add service
$FFPROBE_CMD $FFPROBE_OPTS_GLOBAL $FFPROBE_OPTS_STREAMS $MUX_URL >> $TVHEADEND_JTV_HOME_INFO_LOG_FILE 2>&1 

# Check if service was added 
# ..........................
# SERVICE_ADDED=1 means service was found
SERVICE_ADDED=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .num_svc')
#
# Test for whether stream was working
if [ "$SERVICE_ADDED" != "1" ];
then
# Log failed streams
cat >> $TVHEADEND_JTV_HOME_FAILED_LOG_FILE << STREAMLOG

*******************************************************************************
$PLAYLIST_CHANNEL ($PLAYLIST_CATEGORY)
*******************************************************************************

Link:	$PLAYLIST_URL

Error:	$(cat $TVHEADEND_JTV_HOME_INFO_LOG_FILE)

STREAMLOG
fi

fi
}

jtvhome_map_services_2_channels () {
# Quit if JTV Home playlist file is missing
jtvhome_quit_if_no_playlist_found

# Notify of JTV Home network mapping start
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$JTV_HOME_CHANNEL_MAP_STARTED_MESSAGE" text
# Print notification using OSD tool
print_notification "$JTV_HOME_CHANNEL_MAP_STARTED_MESSAGE" osd

# Remove dead channels
zap_dead_channels

# Start temporary RTMP/HLS streaming
jtvhome_rtmp_streaming_start

# Cycle through all JTV HOME MUX IDs and test to create services
# ..............................................................
# Set Network UUID
TVHEADEND_JTV_HOME_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_JTV_HOME_NETWORK_NAME"'") | .uuid')

$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.network_uuid=="'"$TVHEADEND_JTV_HOME_NETWORK_UUID"'") | .uuid' | while read MUX_UUID

do
# Do not play if we already have a service
SERVICE_ADDED=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .num_svc')
SERVICE_NAME=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .name' | sed "s:$PLAYLISTS_JTV_HOME_M3U_FILE - ::g" | sed "s:^-*::g")
#
# Test stream
jtvhome_test_stream
done

# Create JTV Home channels
# ........................
# Remove previous temp script file for creating JTV Home channels
[[ -e $TVHEADEND_JTV_HOME_CREATE_CHAN_TEMP_FILE ]] && sudo rm -f $TVHEADEND_JTV_HOME_CREATE_CHAN_TEMP_FILE 
# Remove previous temp service UUID raw file for JTV Home services
[[ -e $TVHEADEND_JTV_HOME_SERVICE_UUIDS_RAW_FILE ]] && sudo rm -f $TVHEADEND_JTV_HOME_SERVICE_UUIDS_RAW_FILE
# Create service UUIDs file
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq -r '.entries[] | select(.text | contains("'"${TVHEADEND_JTV_HOME_NETWORK_NAME}"'")).uuid' > $TVHEADEND_JTV_HOME_SERVICE_UUIDS_RAW_FILE
#
# Cycle through JTV Home services
cat $TVHEADEND_JTV_HOME_SERVICE_UUIDS_RAW_FILE | while read SERVICE_UUID
do
CHANNEL_NAME=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$SERVICE_UUID"'") | .text' | sed "s:$TVHEADEND_JTV_HOME_NETWORK_NAME/$PLAYLISTS_JTV_HOME_M3U_FILE - ::g"| cut -d / -f2-)
# Extract channel number from JTV Home playlist
CHANNEL_NUMBER=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_JTV_HOME_M3U_FILE} | grep '#EXTINF' | cut -d = -f5 | awk {'print $1'} | sed 's:"::g' | head -1)
CHANNEL_LOGO=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_JTV_HOME_M3U_FILE} | grep '#EXTINF' | cut -d = -f4 | awk {'print $1'} | sed 's:"::g' | head -1)
CHANNEL_CATEGORY=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_JTV_HOME_M3U_FILE} | grep '#EXTINF' | cut -d , -f1 | awk {'print $NF'} | cut -d = -f2 | sed 's:"::g' | head -1)
CHANNEL_TAG=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/list?limit=100000 | jq -r '.entries[] | select(.val=="'"${CHANNEL_CATEGORY}"'") | .key')

# Check if channel already exists
EXISTING_CHANNEL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] | select(.name | contains("'"$CHANNEL_NAME"'")) |.name' | uniq)
#
# Don't add if channel already exists
[[ "x$EXISTING_CHANNEL"  = "x" ]] || continue

# Play service URL using ffprobe i.e. Activate it to make it usable as a channel
SERVICE_URL="$TVHEADEND_PLAY_STREAM_URL/service/$SERVICE_UUID"

# Probe remote stream using ffprobe i.e. play mux briefly to add service
$FFPROBE_CMD $FFPROBE_OPTS_GLOBAL $FFPROBE_OPTS_STREAMS $SERVICE_URL >> $TVHEADEND_JTV_HOME_INFO_LOG_FILE 2>&1

# Add jtvhome channel creation command to temp file
cat >> $TVHEADEND_JTV_HOME_CREATE_CHAN_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel to TVHeadend backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
	"enabled": true,
	"number": $CHANNEL_NUMBER,
	"icon": "file://$PROJECT_SYSTEM_ICONS_DIR/IPTV/$CHANNEL_LOGO",
	"epgauto": true,
	"dvr_pre_time": 0,
	"dvr_pst_time": 0,
	"epg_running": -1,
	"services": [
		"$SERVICE_UUID"
	],
	"tags": [
		"$CHANNEL_TAG"
	],
	"bouquet": ""
}'
EOT
)
))" $TVHEADEND_API_URL/channel/create > /dev/null 2>&1
#
# Notify - Channel added
logger -s -t $(basename $0) "Found channel number.[$CHANNEL_NUMBER] [$CHANNEL_NAME]"

EOF

done

# Create JTV Home channels script
if [[ -e $TVHEADEND_JTV_HOME_CREATE_CHAN_TEMP_FILE ]];
then
# Prepare create JTV_HOME channels script
sed -i '1i #!/bin/sh' "$TVHEADEND_JTV_HOME_CREATE_CHAN_TEMP_FILE"
chmod 755 $TVHEADEND_JTV_HOME_CREATE_CHAN_TEMP_FILE
# Run script to create JTV_HOME channels
$TVHEADEND_JTV_HOME_CREATE_CHAN_TEMP_FILE
# Pause for a bit to allow JTV_HOME channels to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_JTV_HOME_CREATE_CHAN_TEMP_FILE
fi

# Remove temp service UUID raw file for JTV Home services
[[ -e $TVHEADEND_JTV_HOME_SERVICE_UUIDS_RAW_FILE ]] && sudo rm -f $TVHEADEND_JTV_HOME_SERVICE_UUIDS_RAW_FILE

# Stop temporary RTMP/HLS streaming
jtvhome_rtmp_streaming_stop

# Notify of JTV Home network mapping complete
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$JTV_HOME_CHANNEL_MAP_COMPLETED_MESSAGE" text
# Print notification using OSD tool
print_notification "$JTV_HOME_CHANNEL_MAP_COMPLETED_MESSAGE" osd
}


# Group functions
# ---------------
dvb_functions_task_all () {
	tvheadend_dvbt_configure
	zap_dead_services
	dvb_scan_add_muxes
	dvb_add_channel_tags
	dvb_map_services_2_channels
	dvb_refresh_epg_data
	refresh_tvh_kodi_icons
	notify_tv_server_controller_completed
}

iptv_functions_task_all () {
	iptv_scan_add_services
	iptv_add_channel_tags
	iptv_map_services_2_channels
	iptv_refresh_epg_data
	refresh_tvh_kodi_icons
	notify_tv_server_controller_completed
	send_tvh_playlist_via_telegram # [wireless|wired]
}

cctv_functions_task_all () {
	cctv_scan_add_muxes
	cctv_add_channel_tags
	cctv_map_services_2_channels
}

jtvhome_functions_task_all () {
	jtvhome_scan_add_muxes
	jtvhome_add_channel_tags
	jtvhome_map_services_2_channels
}



#################
#  MAIN SCRIPT  #
#################
# Usage - all
usage

# Generate debug log for this tool runs
[[ "$DEBUG_LOG" = "yes" ]] && generate_debug_log

# Run tasks based on type specified
case $TV_TYPE in
dvb)
# Usage - dvb
usage_and_pre_start_dvb

# Scan
[[ "$TV_TASK" = "scan" ]] && \
	tvheadend_dvbt_configure && \
	zap_dead_services && \
	dvb_scan_add_muxes

# Map
[[ "$TV_TASK" = "map" ]] && \
	dvb_add_channel_tags && \
	dvb_map_services_2_channels

# Refresh epg if requested
[[ "$TV_TASK" = "epg" ]] && \
	dvb_refresh_epg_data 

# Refresh TV icons
[[ "$TV_TASK" = "icons" ]] && \
	refresh_tvh_kodi_icons

# All tasks {scan+map} 
[[ "$TV_TASK" = "all" ]] && \
	dvb_functions_task_all

# Repair damaged DVB-T/T2
[[ "$TV_TASK" = "repair" ]] && \
	check_health_of_dvb_tvheadend_network && \
	refresh_tvh_kodi_icons && \
	send_tvh_playlist_via_telegram # [wireless|wired]
;;

iptv)
# Usage - iptv
usage_and_pre_start_iptv

# Check for Internet connectivity if not mapping
if [[ "$TV_TASK" != "map" && "$TV_TASK" != "enable" && "$TV_TASK" != "disable" ]];
then
check_internet_connectivity_ping 1
fi

# Fetch fresh playlist if m3u is requested
[[ "$TV_TASK" = "m3u" ]] && \
	iptv_get_fresh_playlist

# Add IPTV Network if it does not exist (except for m3u, epg, icons,enable)
[[ "$TV_TASK" = "map" || "$TV_TASK" = "m3u" || "$TV_TASK" = "epg" || "$TV_TASK" = "icons" || "$TV_TASK" = "enable" || "$TV_TASK" = "disable" ]] || \
	configure_iptv_network

# Add Services i.e. Manually play each mux found
[[ "$TV_TASK" = "scan" ]] && \
	iptv_scan_add_services

# Map
[[ "$TV_TASK" = "map" ]] && \
	iptv_add_channel_tags && \
	iptv_map_services_2_channels

# Download and refresh epg if requested
[[ "$TV_TASK" = "epg" ]] && \
	iptv_refresh_epg_data

# Refresh TV icons
[[ "$TV_TASK" = "icons" ]] && \
	refresh_tvh_kodi_icons

# Enable IPTV network
[[ "$TV_TASK" = "enable" ]] && \
	enable_iptv_network

# Disable IPTV network
[[ "$TV_TASK" = "disable" ]] && \
	disable_iptv_network

# All tasks {m3u+scan+map+epg} 
[[ "$TV_TASK" = "all" ]] && \
	iptv_functions_task_all
;;

cctv)
# Usage - cctv
usage_and_pre_start_cctv

# Add CCTV network
configure_cctv_network

# Scan
[[ "$TV_TASK" = "scan" ]] && \
	cctv_scan_add_muxes 

# Map
[[ "$TV_TASK" = "map" ]] && \
	cctv_add_channel_tags && \
	cctv_map_services_2_channels

# All tasks {scan+map} 
[[ "$TV_TASK" = "all" ]] && \
	cctv_functions_task_all
;;

jtvhome)
# Usage - jtvhome
usage_and_pre_start_jtvhome

# Add JTV Home network
configure_jtvhome_network

# Scan
[[ "$TV_TASK" = "scan" ]] && \
	jtvhome_scan_add_muxes 

# Map
[[ "$TV_TASK" = "map" ]] && \
	jtvhome_add_channel_tags && \
	jtvhome_map_services_2_channels

# All tasks {scan+map} 
[[ "$TV_TASK" = "all" ]] && \
	jtvhome_functions_task_all
;;

general)
# Usage - all
usage_and_pre_start_general

# Get connected clients and their details
[[ "$TV_TASK" = "clients" ]] && \
	get_tvh_clients_connected
;;
esac

post_config
