#!/bin/sh
# This script is used to create DVB-T and IPTV channels in TVHeadend using CLI.
# Use it after services for both have been generated
# Also used in forcing IPTV network to scan from the command line
# Jambula Labs @copyright 2018-2019 All rights reserved

# Variables
PROJECT_NAME=JambulaTV
PROJECT_SYSTEM_CONF_DIR=/etc/$PROJECT_NAME
PROJECT_FUNCTIONS_FILE=$PROJECT_SYSTEM_CONF_DIR/functions
PROJECT_DVBT_SETTINGS_FILE=$PROJECT_SYSTEM_CONF_DIR/dvbt-settings.cfg

# Source install functions
. $PROJECT_FUNCTIONS_FILE

# Source DVBT settings file
. $PROJECT_DVBT_SETTINGS_FILE

# Other variables
TIMEOUT_PROBE="80s"
TIMEOUT_CMD="/usr/bin/timeout $TIMEOUT_PROBE"
FFPROBE_CMD="$TIMEOUT_CMD /usr/bin/ffprobe"
FFPROBE_OPTS="-hide_banner"
YOUTUBE_CMD="/usr/bin/jambulatv-youtube"
YOUTUBE_VARIABLES_TEMP_FILE=$(grep ^YOUTUBE_VARIABLES_TEMP_FILE $YOUTUBE_CMD | cut -d '=' -f2 | head -1 | awk {'print $1'} | sed 's/"//g')

# Email
EMAIL_ADDRESS_USER=$(grep -i EMAIL_TO_ADDRESS $EMAIL_CREDENTIALS_CONFIG | sed '/^#/d' | cut -d = -f2 | sed 's/"//g')

# Product serial number
SERIAL=$(grep -i Serial $PROJECT_RELEASE_FILE | cut -d : -f2)

# TVHeadend
TVHEADEND_API_URL="http://${TVHEADEND_HTTP_IP}:${TVHEADEND_HTTP_PORT}/api"
TVHEADEND_DVBT_TUNER_NODE=/dev/dvb/adapter$DVBT_TUNER_NO
TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE=/tmp/create_dvb_channels.sh
TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE=/tmp/create_dvb_channel_tags.sh
TVHEADEND_PLAY_STREAM_URL="http://${TVHEADEND_HTTP_IP}:${TVHEADEND_HTTP_PORT}/play/stream"
TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE=/tmp/iptv_service_uuid.txt
TVHEADEND_IPTV_INFO_LOG_FILE=$TVHEADEND_IPTV_LOG_DIR/iptv-scan-info.$(date +%Y%m%d%H%M).log
TVHEADEND_IPTV_FAILED_LOG_FILE=$TVHEADEND_IPTV_LOG_DIR/iptv-scan-failed.$(date +%Y%m%d%H%M).log
TVHEADEND_IPTV_SERVICE_LOG_FILE=/tmp/iptv_service_output.log
TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE=/tmp/create_iptv_channels.sh
TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE=/tmp/create_iptv_channel_tags.sh
TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE=/tmp/iptv_scanning_in_progress
TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE=/tmp/iptv_mapping_in_progress

TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE=/tmp/create_cctv_channels.sh
TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE=/tmp/create_cctv_channel_tags.sh
TVHEADEND_CCTV_INFO_LOG_FILE=$TVHEADEND_IPTV_LOG_DIR/cctv-scan-info.$(date +%Y%m%d%H%M).log
TVHEADEND_CCTV_SERVICE_UUIDS_RAW_FILE=/tmp/cctv_service_uuid.txt

PLAYLISTS_PORT=MY_PLAYLISTS_PORT

IPTV_BUILDER_BASE_DIR=/opt/jambula-iptv-builder
IPTV_BUILDER_GROUPS_DIR=$IPTV_BUILDER_BASE_DIR/groups

TV_TYPE=$1
TV_TASK=$2

# Generate log file
DEBUG_LOG=no



###############
#  FUNCTIONS  #
###############
usage () {
# Device Name
if [ "x$TV_TYPE" = "x" ];
then
clear
echo "Usage:  ./`basename $0` [dvb|iptv|cctv]
"
exit 1
fi
}

usage_and_pre_start_dvb () {
if [[ "x$TV_TASK" = "x" ]];
then
clear
echo "Usage:  ./`basename $0` dvb [scan|map|all|repair|epg|icons]
"
exit 1

# Don't proceed if TV_TASK is epg, icons)
elif [[ "$TV_TASK" = "m3u" || "$TV_TASK" = "epg" || "$TV_TASK" = "icons" ]];
then
# Notify when TV server controller process has been initiated
notify_tv_server_controller_initiated
# Break out
break

else
# Notify when TV server controller process has been initiated
notify_tv_server_controller_initiated
#
# Check to see if TVHeadend server is in use
check_if_in_use 
fi
}

usage_and_pre_start_iptv () {
if [[ "x$TV_TASK" = "x" ]];
then
clear
echo "Usage:  ./`basename $0` iptv [scan|map|all|m3u|epg|icons]
"
exit 1

# Don't proceed if TV_TASK is m3u, epg, icons)
elif [[ "$TV_TASK" = "m3u" || "$TV_TASK" = "epg" || "$TV_TASK" = "icons" ]];
then
# Notify when TV server controller process has been initiated
notify_tv_server_controller_initiated
# Break out
break

else
# Notify when TV server controller process has been initiated
notify_tv_server_controller_initiated
#
# Check to see if TVHeadend server is in use
check_if_in_use 
fi
}

usage_and_pre_start_cctv () {
if [ "x$TV_TASK" = "x" ];
then
clear
echo "Usage:  ./`basename $0` cctv [scan|map|all]
"
exit 1

else
# Notify when TV server controller process has been initiated
notify_tv_server_controller_initiated
#
# Check to see if TVHeadend server is in use
check_if_in_use
fi
}

generate_debug_log () {
PARENT_COMMAND="$(ps -o comm= $PPID)"
cat >> $TVHEADEND_LOG_DIR/$(basename $0).log <<EOT

$(date +'%b %d %I:%M:%S') [$PARENT_COMMAND] Running '$(basename $0) $TV_TYPE $TV_TASK'
-----------------------------------------------------------------------------------------
EOT
# Start Logging
exec 2>> $PROJECT_SYSTEM_LOG_DIR/$(basename $0).log
}

check_if_in_use () {
CURRENT_PROFILES=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/status/subscriptions | jq -r '.entries[] | .profile' | sed 's:null::g')
CURRENT_CHANNELS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/status/subscriptions | jq -r '.entries[] | .channel' | sed 's:null::g')
#
# Quit if TVH Server is being used i.e. Playing TV
if [ "x$CURRENT_CHANNELS" != "x" ] || [ "x$CURRENT_PROFILES" != "x" ];
then
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$TVHEADEND_SERVER_IN_USE_MESSAGE" text
# Print notification using OSD tool
print_notification "$TVHEADEND_SERVER_IN_USE_MESSAGE" osd
exit 1
fi
}

notify_tv_server_controller_initiated () {
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$TVHEADEND_SERVER_REFRESH_START_MESSAGE" text
# Print notification using OSD tool
print_notification "$TVHEADEND_SERVER_REFRESH_START_MESSAGE" osd
}

notify_tv_server_controller_completed () {
sleep 30
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$TVHEADEND_SERVER_REFRESH_STOP_MESSAGE" text
# Print notification using OSD tool
print_notification "$TVHEADEND_SERVER_REFRESH_STOP_MESSAGE" osd
}

log_file () {
# Create IPTV log directory if non existent
[ -d $TVHEADEND_IPTV_LOG_DIR ] || mkdir -p $TVHEADEND_IPTV_LOG_DIR
# Give it Multimedia user's permissions
chown -R $MULTIMEDIA_USER:$MULTIMEDIA_USER $TVHEADEND_IPTV_LOG_DIR

# Date stamp log file
cat >> $TVHEADEND_IPTV_INFO_LOG_FILE <<EOT

###############################################################################
IPTV services scan performed on:  $(date)
###############################################################################

EOT
}

tvheadend_restart_server () {
# Give multimedia user permission to access tvheadend directories
chown -R $MULTIMEDIA_USER:video $TVHEADEND_CONFIG_DIR
#
# Restart TVHeadend
sudo systemctl restart tvheadend.service
}

pre_config () {
# Create channels directory, if non-existent
[ -d $TVHEADEND_CHANNELS_CONFIG_DIR ] || mkdir -p $TVHEADEND_CHANNELS_CONFIG_DIR
#
# Load IPTV Lists i.e. restart tvheadend
tvheadend_restart_server
}

post_config () {
# Restart TVHeadend for all tasks except for m3u, epg, icons)
[[ "$TV_TASK" = "m3u" || "$TV_TASK" = "epg" || "$TV_TASK" = "icons" ]] || \
tvheadend_restart_server
}

email_failed_iptv_notice () {
# Email notice regarding failed IPTV streams
[ -e "$TVHEADEND_IPTV_FAILED_LOG_FILE" ] && \
	$EMAIL_VIA_GMAIL_TOOL $EMAIL_ADDRESS_ERRORS "[JambulaTV]: IPTV services failed" "The following IPTV streams are no longer working at the following JambulaTV user: Serial No. $SERIAL" $TVHEADEND_IPTV_FAILED_LOG_FILE
}

zap_dead_services () { 
# Find dead services and remove them 
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/removeunseen > /dev/null 2>&1
}

zap_dead_channels () { 
# Find dead channels and remove them before mapping
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] | select(.name | contains("name-not-set")).uuid' | while read DEAD_CHANNEL_UUID
do
rm -f $TVHEADEND_CHANNELS_CONFIG_DIR/$DEAD_CHANNEL_UUID
done

# Remove previously added channels that no longer have services associated to them i.e. Don't play anymore. 
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] |.name,.services,.uuid' | grep -A1 "\[\]" | grep -Ev "(--|\[\])" | while read DEAD_CHANNEL_UUID
do
rm -f $TVHEADEND_CHANNELS_CONFIG_DIR/$DEAD_CHANNEL_UUID
done

# Restart TVH server
tvheadend_restart_server
}

get_tvheadend_last_channel_number () {
# DVB-T channels
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] | select(.name!="name-not-set") | .number'| sort -n | grep -e '^1$' -e '^2$' > /dev/null 2>&1
TVHEADEND_DVBT_CHANNELS_EXIST=$?
#
# Non-DVB-T channels
TVHEADEND_LAST_CHANNEL_NUMBER=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] | select(.name!="name-not-set") | .number'| sort -n | tail -1)
}

refresh_tvh_kodi_icons () {
# Notify of refresh of TV icons
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$KODI_REFRESH_TV_LOGOS_MESSAGE" text
# Print notification using OSD tool
print_notification "$KODI_REFRESH_TV_LOGOS_MESSAGE" osd
#
# Clean and Trigger imagecache in TVHeadend
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/imagecache/config/clean -d clean=1 > /dev/null 2>&1
#
# Refresh TV logos in kodi
$KODI_CONTROLLER_TOOL tv_picons_repair > /dev/null 2>&1
}


############
#  DVB-T2  #
############
#
dvb_refresh_epg_data () {
# Remove TVH EPG Database
[[ -e $TVHEADEND_CONFIG_DIR/epgdb.v3 ]] && rm -f $TVHEADEND_CONFIG_DIR/epgdb.v3

# Run OTA grabbers
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/epggrab/ota/trigger -d trigger=1 > /dev/null 2>&1
}

dvb_query_scan_status () {
TVH_DVBT_SCAN_STATUS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] |select(.network_uuid=="'"$TVHEADEND_DVBT_NETWORK_UUID"'")|.scan_state' | uniq)
}

dvb_scan_add_muxes () {
# Notify of Live TV scan
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_NETWORK_SCAN_STARTED_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_NETWORK_SCAN_STARTED_MESSAGE" osd
#
TVHEADEND_DVBT_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$DVBT_NETWORK_NAME"'") |.uuid')
#
# Force scan of DVB network
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/scan -d uuid=$TVHEADEND_DVBT_NETWORK_UUID > /dev/null 2>&1
#
dvb_query_scan_status > /dev/null 2>&1
while [[ "$TVH_DVBT_SCAN_STATUS" != "0" ]];
do
# Notify of waiting for services to be added
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_WAITING_4_SERVICES_ADD_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_WAITING_4_SERVICES_ADD_MESSAGE" osd

# Pause a few seconds to allow all services to be added before proceeding to mapping
# of channels
sleep 20
#
dvb_query_scan_status > /dev/null 2>&1
done
}

dvb_add_channel_tags () {
# Remove previous temp script file for creating DVB-T channel tags
[[ -e $TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE ]] && sudo rm -f $TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE 

# Add DVB-T channels tags - Free-To-Air, Local, etc.
for TAG_NAME in "Free-To-Air" "Local" 
do
TAG_EXISTS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'$TAG_NAME'") |.enabled' | sed 's:"::g' | head -1)
TAG_EXISTS_COUNT=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'$TAG_NAME'") |.enabled' | wc -l)

# Test for existence of channel tag and ensure no duplicates are created
if [[ "$TAG_EXISTS" != "true" || "$TAG_EXISTS_COUNT" = "0" ]];
then
# Add DVB-T channel tags creation command to temp file
cat >> $TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel tag to backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
	"enabled": true,
	"index": 0,
	"name": "$TAG_NAME",
	"internal": false,
	"private": false,
	"icon": "",
	"icon_public_url": "",
	"titled_icon": false,
	"comment": "$TAG_NAME Digital TV Channels ($DVBT_NETWORK_NAME)"
}'

EOT
)
))" $TVHEADEND_API_URL/channeltag/create > /dev/null 2>&1
#
# Notify - Channel Tag added
logger -s -t $(basename $0) "Added Channel Tag [$TAG_NAME]"

EOF
fi

done

# Create TV channel tags script
if [[ -e $TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE ]];
then
# Prepare create TV channel tags script
sed -i '1i #!/bin/sh' "$TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE"
chmod 755 $TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE
# Run script to create TV channel tags
$TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE
# Pause for a bit to allow TV channel tags to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_DVBT_CREATE_CHAN_TAG_TEMP_FILE
fi
}

dvb_map_services_2_channels () {
# Notify of DVB-T network mapping start
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_CHANNEL_MAP_STARTED_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_CHANNEL_MAP_STARTED_MESSAGE" osd

# Remove dead channels
zap_dead_channels

# Remove dead services
zap_dead_services

# Remove previous temp script file for creating DVB-T channels
[[ -e $TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE ]] && sudo rm -f $TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE 
#
# Set starting channel number/digit
get_tvheadend_last_channel_number
# Query for last DVB-T channel numbers
if [[ "$TVHEADEND_DVBT_CHANNELS_EXIST" = "0" ]];
then
TVHEADEND_LAST_CHANNEL_NUMBER=$TVHEADEND_LAST_CHANNEL_NUMBER
else
TVHEADEND_LAST_CHANNEL_NUMBER=0
fi
#
let "TVHEADEND_DVB_FIRST_CHANNEL_NUMBER = $TVHEADEND_LAST_CHANNEL_NUMBER + 1"
DIGIT=$TVHEADEND_DVB_FIRST_CHANNEL_NUMBER
#
# Cycle through list of DVB-T2 services that were created
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/service/grid?limit=100000 | jq -r '.entries[] | select(.network=="'"$DVBT_NETWORK_NAME"'")|.svcname' | sort -u | while read LINE

do
CHANNEL_NUMBER=$DIGIT
CHANNEL_NAME="$LINE"
CHANNEL_LOGO=$(echo $CHANNEL_NAME | tr [:lower:] [:upper:]| sed 's: :_:g').png
CHANNEL_TAGS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000  | jq '.entries[] | select(.comment | contains("'"$DVBT_NETWORK_NAME"'")) |.uuid' | paste -s -d",")
SERVICES=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/service/grid?limit=100000 | jq '.entries[] | select(.svcname=="'"$CHANNEL_NAME"'")|.uuid')

# Count number of this DVB-T channel that exists
DVBT_CHANNEL_EXISTS_COUNT=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] | select (.name=="'"$CHANNEL_NAME"'") |.name' | wc -l)

# Test for existence of DVB-T channel - Don't add if channel already exists
[[ "$DVBT_CHANNEL_EXISTS_COUNT" = "0" ]] || break

# Add DVB-T channel creation command to temp file
cat >> $TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel to TVHeadend backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
  "bouquet": "",
  "tags": [
  $CHANNEL_TAGS
  ],
  "services": [
  $SERVICES
  ],
  "epg_running": -1,
  "dvr_pst_time": 0,
  "dvr_pre_time": 0,
  "epggrab": [],
  "epglimit": 0,
  "enabled": true,
  "autoname": false,
  "name": "$CHANNEL_NAME",
  "number": $CHANNEL_NUMBER,
  "icon": "file://$PROJECT_SYSTEM_SHARE_DIR/picons/$TV_MARKET/$CHANNEL_LOGO",
  "epgauto": true
}'

EOT
)
))" $TVHEADEND_API_URL/channel/create > /dev/null 2>&1
#
# Notify - Channel added
logger -s -t $(basename $0) "Added Channel No.[$CHANNEL_NUMBER] [$CHANNEL_NAME]"

EOF
#
#
let "DIGIT = $CHANNEL_NUMBER + 1"
done

# Create DVB-T channels script
if [[ -e $TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE ]];
then
# Prepare create DVB-T channels script
sed -i '1i #!/bin/sh' "$TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE"
chmod 755 $TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE
# Run script to create DVB-T channels
$TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE
# Pause for a bit to allow DVB-T channels to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_DVBT_CREATE_CHAN_TEMP_FILE
fi

# Notify of DVB-T network mapping complete
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_CHANNEL_MAP_COMPLETED_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_CHANNEL_MAP_COMPLETED_MESSAGE" osd
}

repair_dvb_tvheadend_network () {
# Quit if, there's already a process to reset or repair tvheadend
if [[ -e $TVHEADEND_REPAIR_IN_PROGRESS_TEMP_FILE ]] || \
	[[ -e $TVHEADEND_REPAIR_IN_PROGRESS_TEMP_FILE ]]
then
# Notify of termination of reset
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_NETWORK_REPAIR_TERMINATED" text
# Print notification using OSD tool
print_notification "$DVBT_NETWORK_REPAIR_TERMINATED" osd

# Quit
exit 0
fi

# Quit if TVHeadend is NOT running because of other process like CCTV being configured
systemctl -q is-active tvheadend.service || exit

# Notify start of DVB-T network repair process
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_NETWORK_REPAIR_STARTED_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_NETWORK_REPAIR_STARTED_MESSAGE" osd

# Add control file for other apps to know that TVHeadend Repair is in progress
[ -e $TVHEADEND_REPAIR_IN_PROGRESS_TEMP_FILE ] || \
touch $TVHEADEND_REPAIR_IN_PROGRESS_TEMP_FILE

# Remove corrupted DVB-T network config files if existent
if [[ -d $TVHEADEND_DVBT_NETWORK_CONFIG_DIR ]];
then
# Remove config directories with empty config files i.e. corrupted DVB-T networks
rm -rf $(find $TVHEADEND_DVBT_NETWORK_CONFIG_DIR -iname config -size 0 -type f -exec dirname {} \;)
fi

# Configure DVBT network afresh
dvb_functions_task_all

# Remove control file for other apps to know that TVHeadend Repair completed
[ -e $TVHEADEND_REPAIR_IN_PROGRESS_TEMP_FILE ] && \
sudo rm -f $TVHEADEND_REPAIR_IN_PROGRESS_TEMP_FILE
}

check_health_of_dvb_tvheadend_network () {
# Notify of DVB-T health status check
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_CHECK_HEALTH_STATUS_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_CHECK_HEALTH_STATUS_MESSAGE" osd

# See if DVBT network UUID exists
TVHEADEND_DVBT_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$DVBT_NETWORK_NAME"'") |.uuid')
#
# Set DVB-T matched to adapter variable
if [[ "x$TVHEADEND_DVBT_NETWORK_UUID" != "x" ]];
then
# Check if DVB network is correctly associated with the DVB-T2 tuner adapter
sudo grep -rli $TVHEADEND_DVBT_NETWORK_UUID $TVHEADEND_ADAPTERS_CONFIG_DIR > /dev/null 2>&1
DVBT_NETWORK_MATCHED_WITH_TUNER=$?
fi

# 1) If no DVB-T2 tuner was found
# -------------------------------
if [[ ! -e "$TVHEADEND_DVBT_TUNER_NODE" ]];
then
# Notify of DVB-T tuner missing
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_ADAPTER_NODE_MISSING_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_ADAPTER_NODE_MISSING_MESSAGE" osd

# Quit
exit 0


# 2) If DVBT Network was accidentally wiped out
# ---------------------------------------------
elif [[ "x$TVHEADEND_DVBT_NETWORK_UUID" = "x" ]];
then

# Notify of DVB-T network missing
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_NETWORK_MISSING_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_NETWORK_MISSING_MESSAGE" osd

# Start DVB-T network repair process
repair_dvb_tvheadend_network 


# 3) If DVB-T network is not associated with the DVB-T tuner adapter
# ------------------------------------------------------------------
elif [[ "$DVBT_NETWORK_MATCHED_WITH_TUNER" != "0" && \
	"x$TVHEADEND_DVBT_NETWORK_UUID" != "x" ]];
then
# Notify of DVB-T network not being associated to any tuner
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_NETWORK_NOT_ASSOCIATED_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_NETWORK_NOT_ASSOCIATED_MESSAGE" osd

# Delete this network and prepare to start afresh
$CURL_CMD $CURL_OPTS -d uuid="$TVHEADEND_DVBT_NETWORK_UUID" $TVHEADEND_API_URL/idnode/delete > /dev/null 2>&1

# Start DVB-T network repair process
repair_dvb_tvheadend_network 


else

# Notify of DVB-T health status is OK
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$DVBT_HEALTH_STATUS_OK_MESSAGE" text
# Print notification using OSD tool
print_notification "$DVBT_HEALTH_STATUS_OK_MESSAGE" osd

# Quit
exit 0
fi
}


##########
#  IPTV  #
##########
#
iptv_get_fresh_playlist () {
# Notify that playlist is going to be downloaded
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$IPTV_FETCH_PLAYLIST_MESSAGE" text
# Print notification using OSD tool
print_notification "$IPTV_FETCH_PLAYLIST_MESSAGE" osd

# Fetch fresh IPTV playlists file from remote FTP server
ftp_connect_get_file $(basename $JAMBULATV_FTP_SERVER_IPTV_DIR_NAME)/ $PLAYLISTS_IPTV_WORLD_M3U_FILE $TMPDIR/
#
# Add fresh IPTV m3u8 file to JambulaTV playlists directory
[ -s $TMPDIR/$PLAYLISTS_IPTV_WORLD_M3U_FILE ] && \
	rsync -qavz --delay-updates $TMPDIR/$PLAYLISTS_IPTV_WORLD_M3U_FILE $PLAYLISTS_DIRECTORY/
# Remove temp IPTV playlist file
[ -e $TMPDIR/$PLAYLISTS_IPTV_WORLD_M3U_FILE ] && rm -f $TMPDIR/$PLAYLISTS_IPTV_WORLD_M3U_FILE
}

iptv_download_epg_data () {
# Cycle through all desired TV guides: UK, US
for EPG_XMLTV_COUNTRY in UK US
do
# Source EPG XMLTV guide sources by country
epg_xmltv_guide_sources 

# Check the age of the EPG data file and set whether it is fresh or not
[[ -e "$EPG_XMLTV_GUIDE_FILE" && "$(date -d "now - $(stat -c "%Y" $EPG_XMLTV_GUIDE_FILE) seconds" +%s)" -lt "$EPG_XMLTV_GUIDE_FILE_AGE" ]] && TV_GUIDE_FILE_IS_FRESH=yes

# Download only if EPG data file is 3 days old or more since the XML file is huge ~50MB
if [[ "$TV_GUIDE_FILE_IS_FRESH" != "yes" ]];
then

# Notify of start of EPG data download
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$EPG_DATA_DOWNLOAD_START_MESSAGE" text
# Print notification using OSD tool
print_notification "$EPG_DATA_DOWNLOAD_START_MESSAGE" osd

# Remove previous TV guide if more than than three days
[[ -e $EPG_XMLTV_GUIDE_FILE ]] && rm -f $EPG_XMLTV_GUIDE_FILE
# Give multimedia user access to the log file
[[ -e $EPG_XMLTV_LOG_FILE ]] && \
	sudo chown -R $MULTIMEDIA_USER:$MULTIMEDIA_USER $EPG_XMLTV_LOG_FILE

# Add EPG downloaded date header to log file
cat >> $EPG_XMLTV_LOG_FILE <<EOT

###############################################################################
Electronic Program Guide (EPG) Information for:		$EPG_XMLTV_COUNTRY
###############################################################################
EOT

# Download the latest TV guide (EPG) from upstream providor
wget_download_file $EPG_XMLTV_GUIDE_FILE $EPG_XMLTV_GUIDE_URL -a $EPG_XMLTV_LOG_FILE

# Determine file format of downloaded tvguide
EPG_XMLTV_GUIDE_FILE_FORMAT=$(file -b $EPG_XMLTV_GUIDE_FILE | awk {'print $1'})

# If file is compressed, then decompress per type
case $EPG_XMLTV_GUIDE_FILE_FORMAT in
#
# Gzip
[Gg][Zz][Ii][Pp])
# Rename
mv -v ${EPG_XMLTV_GUIDE_FILE} ${EPG_XMLTV_GUIDE_FILE}.gz
# Decompress
gunzip -v ${EPG_XMLTV_GUIDE_FILE}.gz
;;
#
# Zip 
[Zz][Ii][Pp])
# Rename
mv -v ${EPG_XMLTV_GUIDE_FILE} ${EPG_XMLTV_GUIDE_FILE}.zip
# Decompress
unzip -v ${EPG_XMLTV_GUIDE_FILE}.zip
;;
#
# Bzip2
[Bb][Zz][Ii][Pp]2)
# Rename
mv -v ${EPG_XMLTV_GUIDE_FILE} ${EPG_XMLTV_GUIDE_FILE}.bzip2
# Decompress
bunzip2 -v ${EPG_XMLTV_GUIDE_FILE}.bzip2
;;
#
# XZ
[Xx][Zz])
# Rename
mv -v ${EPG_XMLTV_GUIDE_FILE} ${EPG_XMLTV_GUIDE_FILE}.xz
# Decompress
unxz -v ${EPG_XMLTV_GUIDE_FILE}.xz
;;
esac

fi

done
}

iptv_refresh_epg_data () {
# Run TVH internal EPG grabbers e.g. xmltv: tv_grab_combiner -> tv_grab_uk_bleb
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/epggrab/internal/rerun -d rerun=1 > /dev/null 2>&1

# Download latest EPG data from upstream XMLTV provider
iptv_download_epg_data

# Notify of refresh of EPG data
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$EPG_DATA_4_KODI_REFRESH_MESSAGE" text
# Print notification using OSD tool
print_notification "$EPG_DATA_4_KODI_REFRESH_MESSAGE" osd
#
# Cycle through all desired TV guides: UK, US
for EPG_XMLTV_COUNTRY in UK US
do
# Source EPG XMLTV guide sources by country
epg_xmltv_guide_sources 

# Pipe EPG data into TVHeadend XMLTV EPG grabber module
[[ -e $EPG_XMLTV_GUIDE_FILE ]] && cat $EPG_XMLTV_GUIDE_FILE | \
	sudo $SOCAT_CMD $SOCAT_OPTS - UNIX-CONNECT:$EPG_XMLTV_SOCKET

# Add XMLTV based grabber listings for UK if available
logger -s -t $(basename $0) "Added TV guide for [$EPG_XMLTV_COUNTRY] to TVHeadend EPG grabber"
done
}

iptv_scan_add_muxes () {
# Set Network UUID - Keep this here, not top
TVHEADEND_IPTV_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") | .uuid')
#
# Force scan of IPTV network
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/scan -d uuid=$TVHEADEND_IPTV_NETWORK_UUID > /dev/null 2>&1
}

configure_iptv_network () {
# Set Network UUID - Keep this here, not top
TVHEADEND_IPTV_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") | .uuid')
#
# See IPTV network similar to what we want already exists
SIMILAR_IPTV_NETWORK_FOUND=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") |.networkname')
#
# Test for existing IPTV network
if [[ "x$TVHEADEND_IPTV_NETWORK_UUID" != "x" || "x$SIMILAR_IPTV_NETWORK_FOUND" != "x" ]];
then
# Notify of IPTV network already existing and proceed
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$TVHEADEND_IPTV_NETWORK_NAME $IPTV_NETWORK_EXISTS_MESSAGE" text
# Print notification using OSD tool
print_notification "$TVHEADEND_IPTV_NETWORK_NAME $IPTV_NETWORK_EXISTS_MESSAGE" osd

else
# Add IPTV network
iptv_tvheadend_network_add

fi

# Add Muxes i.e. Force scan
iptv_scan_add_muxes 
}

iptv_test_stream () {
# Stream variables
MUX_URL="$TVHEADEND_PLAY_STREAM_URL/mux/$MUX_UUID"
PLAYLIST_URL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'$MUX_UUID'") | .iptv_url')
PLAYLIST_CATEGORY=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'$MUX_UUID'") | .iptv_tags' | head -1)
PLAYLIST_CHANNEL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'$MUX_UUID'") | .iptv_sname' | head -1)
PLAYLIST_PIPE_COMMAND="$(echo $PLAYLIST_URL | sed 's|pipe://||g')"

# Add to log file
echo 2>&1 | tee -a $TVHEADEND_IPTV_INFO_LOG_FILE << EOF


*******************************************************************************
JambulaTV: Testing IPTV stream: [$SERVICE_NAME], please wait ...
*******************************************************************************

EOF
# Probe remote stream using ffprobe i.e. play mux briefly to add service
$FFPROBE_CMD $FFPROBE_OPTS $MUX_URL 2>&1 | tee -a $TVHEADEND_IPTV_INFO_LOG_FILE > $TVHEADEND_IPTV_SERVICE_LOG_FILE

# Check if service was added i.e. Remote Link works
SERVICE_ADDED=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .num_svc')

# Test for whether stream was working
if [ "$SERVICE_ADDED" != "1" ];
then
# Log failed streams
cat >> $TVHEADEND_IPTV_FAILED_LOG_FILE << STREAMLOG

*******************************************************************************
$PLAYLIST_CHANNEL ($PLAYLIST_CATEGORY)
*******************************************************************************

Link:	$PLAYLIST_URL

Error:	$(cat $TVHEADEND_IPTV_SERVICE_LOG_FILE)

STREAMLOG
fi
}

iptv_scan_add_services () {
# timestamp log file
log_file
#
# Add control file for other apps to know that IPTV scan is in progress
[ -e $TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE ] || touch $TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE
#
# Remove dead services
zap_dead_services

# Notify of IPTV network scan start
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$IPTV_NETWORK_SCAN_STARTED_MESSAGE" text
# Print notification using OSD tool
print_notification "$IPTV_NETWORK_SCAN_STARTED_MESSAGE" osd

# Set Network UUID - Keep this here, not top
TVHEADEND_IPTV_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") | .uuid')
#
# ----------------------------------------------------------
# Cycle through all IPTV MUX IDs and test to create services
# ----------------------------------------------------------
#
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.network_uuid=="'"$TVHEADEND_IPTV_NETWORK_UUID"'") | .uuid' | while read MUX_UUID

do
# Do not play if we already have a service
SERVICE_ADDED=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .num_svc')
SERVICE_NAME=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .name' | sed "s:$PLAYLISTS_IPTV_WORLD_M3U_FILE - ::g")
# Pipe stream variables
PLAYLIST_URL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'$MUX_UUID'") | .iptv_url')
PLAYLIST_CHANNEL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq -r '.entries[] | select(.uuid=="'$MUX_UUID'") | .iptv_sname' | head -1)
PLAYLIST_PIPE_COMMAND="$(echo $PLAYLIST_URL | sed 's|pipe://||g')"
#
echo $PLAYLIST_URL | grep $PLAYLIST_PIPE_COMMAND > /dev/null 2>&1
IS_YPIPE=$?

# Add service if none existent. Force testing of Youtube pipes
# ............................................................
# SERVICE_ADDED=1 means service was found
# IS_YPIPE=0 means URL is a Youtube pipe
if [[ "$SERVICE_ADDED" != "1" || "$IS_YPIPE" = "0" ]];
then
# Play mux 
iptv_test_stream
fi

done
#
# Email failed IPTV streams
email_failed_iptv_notice
#
# Remove control file for other apps to know that IPTV scan completed
[ -e $TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE ] && sudo rm -f $TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE
}

get_channel_number_using_iptv_builder () {
#
# Variables
CHANNEL_NUMBER_TEMP_FILE=/tmp/chan_number
CHANNEL_COUNT=$(grep -iEw "${CHANNEL_NAME}" -d skip $IPTV_BUILDER_GROUPS_DIR/* | cut -d '|' -f2 | sed 's: ::g' | wc -l)
# Remove existing file
[ -e $CHANNEL_NUMBER_TEMP_FILE ] && rm -f $CHANNEL_NUMBER_TEMP_FILE
# Find channel number, if more than one match
if [ "$CHANNEL_COUNT" -gt "1" ];
then

grep -iEw "${CHANNEL_NAME}" -d skip $IPTV_BUILDER_GROUPS_DIR/* | while read LINE
do
COL1=$(echo $LINE | cut -d ':' -f2 | cut -d '|' -f1 | sed 's/ $//')
COL2=$(echo $LINE | cut -d ':' -f2 | cut -d '|' -f2 | sed 's/ //g')
if [ "$COL1" = "$CHANNEL_NAME" ];
then
# Set channel number
echo "CHANNEL_NUMBER=$COL2" > $CHANNEL_NUMBER_TEMP_FILE
fi
break
done 

else
# Find channel number, if only one match
CHANNEL_NUMBER=$(grep -iEw "${CHANNEL_NAME}" -d skip $IPTV_BUILDER_GROUPS_DIR/* | cut -d '|' -f2 | sed 's: ::g' | head -1)
fi
# Source temp channel number file i.e. Get channel number
[ -e $CHANNEL_NUMBER_TEMP_FILE ] && . $CHANNEL_NUMBER_TEMP_FILE
# Export
export CHANNEL_NUMBER
}

iptv_map_services_2_channels () {
# Add control file for other apps to know that IPTV map is in progress
[ -e $TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE ] || touch $TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE

# Notify of IPTV network mapping start
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$IPTV_CHANNEL_MAP_STARTED_MESSAGE" text
# Print notification using OSD tool
print_notification "$IPTV_CHANNEL_MAP_STARTED_MESSAGE" osd

# Remove dead channels
zap_dead_channels
#
# Remove previous temp script file for creating IPTV channels
[[ -e $TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE ]] && sudo rm -f $TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE 
#
# Cycle through IPTV services
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq -r '.entries[] | select(.text | contains("'${TVHEADEND_IPTV_NETWORK_NAME}'")).uuid' > $TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE
cat $TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE | while read SERVICE_UUID
do
CHANNEL_NAME=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq -r '.entries[] | select(.uuid=="'$SERVICE_UUID'") | .text' | sed "s:$TVHEADEND_IPTV_NETWORK_NAME/$PLAYLISTS_IPTV_WORLD_M3U_FILE - ::g"| cut -d / -f2-)
# Extract channel number from iptv group files
get_channel_number_using_iptv_builder
#
CHANNEL_LOGO=$(echo $CHANNEL_NAME | tr [:upper:] [:lower:]| sed 's: :_:g').png
CHANNEL_CATEGORY=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_IPTV_WORLD_M3U_FILE} | grep '#EXTINF' | cut -d , -f1 | awk {'print $NF'} | cut -d = -f2 | sed 's:"::g' | head -1)
CHANNEL_TAG=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/list?limit=100000 | jq -r '.entries[] | select(.val=="'${CHANNEL_CATEGORY}'") | .key')
#
# Check if channel already exists
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[]' | grep "$SERVICE_UUID" > /dev/null 2>&1
CHANNEL_EXISTS=$?
#
# Don't add if channel already exists
[ "$CHANNEL_EXISTS" = "0" ] && continue

# Play service URL using ffprobe i.e. Activate it to make it usable as a channel
SERVICE_URL="$TVHEADEND_PLAY_STREAM_URL/service/$SERVICE_UUID"

# Add IPTV channel creation command to temp file
cat >> $TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel to TVHeadend backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
	"enabled": true,
	"number": $CHANNEL_NUMBER,
	"icon": "file://$PROJECT_SYSTEM_ICONS_DIR/IPTV/$CHANNEL_LOGO",
	"epgauto": true,
	"dvr_pre_time": 0,
	"dvr_pst_time": 0,
	"epg_running": -1,
	"services": [
		"$SERVICE_UUID"
	],
	"tags": [
		"$CHANNEL_TAG"
	],
	"bouquet": ""
}'
EOT
)
))" $TVHEADEND_API_URL/channel/create > /dev/null 2>&1
#
# Notify - Channel added
logger -s -t $(basename $0) "Added Channel No.[$CHANNEL_NUMBER] [$CHANNEL_NAME]"

EOF

done

# Create IPTV channels script
if [[ -e $TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE ]];
then
# Prepare create IPTV channels script
sed -i '1i #!/bin/sh' "$TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE"
chmod 755 $TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE
# Run script to create IPTV channels
$TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE
# Pause for a bit to allow IPTV channels to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_IPTV_CREATE_CHAN_TEMP_FILE
fi

# Notify of IPTV network mapping complete
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$IPTV_CHANNEL_MAP_COMPLETED_MESSAGE" text
# Print notification using OSD tool
print_notification "$IPTV_CHANNEL_MAP_COMPLETED_MESSAGE" osd

# Remove control file for other apps to know that IPTV map completed
[ -e $TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE ] && sudo rm -f $TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE
}

iptv_add_channel_tags () {
# Remove previous temp script file for creating IPTV channel tags
[[ -e $TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE ]] && sudo rm -f $TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE 

# Cycle through playlist m3u8 file for IPTV channel tag
cat ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_IPTV_WORLD_M3U_FILE} | grep '#EXTINF' | cut -d , -f1 | awk {'print $NF'} | cut -d = -f2 | sed 's:"::g' | sort -u | while read IPTV_CHANNEL
do
TAG_NAME=$IPTV_CHANNEL 
TAG_EXISTS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'$TAG_NAME'") |.enabled' | head -1)
TAG_EXISTS_COUNT=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'$TAG_NAME'") |.enabled' | wc -l)

# Test for existence of channel tag and ensure no duplicates are created
if [[ "$TAG_EXISTS" != "true" || "$TAG_EXISTS_COUNT" = "0" ]];
then
# Add IPTV channel tags creation command to temp file
cat >> $TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel tag to backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
	"enabled": true,
	"index": 0,
	"name": "$TAG_NAME",
	"internal": false,
	"private": false,
	"icon": "",
	"icon_public_url": "",
	"titled_icon": false,
	"comment": "IPTV $TAG_NAME Channels"
}'

EOT
)
))" $TVHEADEND_API_URL/channeltag/create > /dev/null 2>&1
#
# Notify - Channel Tag added
logger -s -t $(basename $0) "Added Channel Tag [$TAG_NAME]"

EOF
fi

done

# Create IPTV channel tags script
if [[ -e $TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE ]];
then
# Prepare create IPTV channel tags script
sed -i '1i #!/bin/sh' "$TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE"
chmod 755 $TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE
# Run script to create IPTV channel tags
$TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE
# Pause for a bit to allow IPTV channel tags to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_IPTV_CREATE_CHAN_TAG_TEMP_FILE
fi
}


##########
#  CCTV  #
##########
#
configure_cctv_network () {
TVHEADEND_CCTV_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_CCTV_NETWORK_NAME"'") |.uuid')
# See CCTV network similar to what we want already exists
SIMILAR_CCTV_NETWORK_FOUND=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_CCTV_NETWORK_NAME"'") |.networkname')
#
# Test for existing CCTV network
if [[ "x$TVHEADEND_CCTV_NETWORK_UUID" != "x" || "x$SIMILAR_CCTV_NETWORK_FOUND" != "x" ]];
then
# Notify of CCTV network already existing and proceed
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$CCTV_NETWORK_EXISTS_MESSAGE" text
# Print notification using OSD tool
print_notification "$CCTV_NETWORK_EXISTS_MESSAGE" osd

else
# Add CCTV network
cctv_tvheadend_network_add
fi
}

cctv_scan_add_muxes () {
TVHEADEND_CCTV_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_CCTV_NETWORK_NAME"'") |.uuid')
# Force scan of CCTV network
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/scan -d uuid=$TVHEADEND_CCTV_NETWORK_UUID > /dev/null 2>&1
}

cctv_add_channel_tags () {
# Remove previous temp script file for creating CCTV channel tags
[[ -e $TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE ]] && sudo rm -f $TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE 

# Cycle through playlist m3u8 file for CCTV channel tag
cat ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_CCTV_LOCAL_M3U_FILE} | grep '#EXTINF' | cut -d , -f1 | awk {'print $NF'} | cut -d = -f2 | sed 's:"::g' | sort -u | while read CCTV_CHANNEL
do
TAG_NAME=$CCTV_CHANNEL 
TAG_EXISTS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'$TAG_NAME'") |.enabled' | head -1)
TAG_EXISTS_COUNT=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'$TAG_NAME'") |.enabled' | wc -l)

# Test for existence of channel tag and ensure no duplicates are created
if [[ "$TAG_EXISTS" != "true" || "$TAG_EXISTS_COUNT" = "0" ]];
then
# Add CCTV channel tags creation command to temp file
cat >> $TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel tag to backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
	"enabled": true,
	"index": 0,
	"name": "$TAG_NAME",
	"internal": false,
	"private": false,
	"icon": "",
	"titled_icon": false,
	"comment": "Web-based $TAG_NAME Channels"
}'

EOT
)
))" $TVHEADEND_API_URL/channeltag/create > /dev/null 2>&1
#
# Notify - Channel Tag added
logger -s -t $(basename $0) "Added Channel Tag [$TAG_NAME]"

EOF
fi

done

# Create CCTV channels script
if [[ -e $TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE ]];
then
# Prepare create CCTV channels script
sed -i '1i #!/bin/sh' "$TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE"
chmod 755 $TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE
# Run script to create CCTV channels
$TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE
# Pause for a bit to allow TV channels to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_CCTV_CREATE_CHAN_TAG_TEMP_FILE
fi
}

cctv_map_services_2_channels () {
# Notify of CCTV network mapping start
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$CCTV_CHANNEL_MAP_STARTED_MESSAGE" text
# Print notification using OSD tool
print_notification "$CCTV_CHANNEL_MAP_STARTED_MESSAGE" osd

# Remove dead channels
zap_dead_channels
#
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq -r '.entries[] | select(.text | contains("'${TVHEADEND_CCTV_NETWORK_NAME}'")).uuid' > $TVHEADEND_CCTV_SERVICE_UUIDS_RAW_FILE

# Remove previous temp script file for creating DVB channels
[[ -e $TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE ]] && sudo rm -f $TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE 
#
# Cycle through CCTV services
cat $TVHEADEND_CCTV_SERVICE_UUIDS_RAW_FILE | while read SERVICE_UUID
do
CHANNEL_NAME=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq -r '.entries[] | select(.uuid=="'$SERVICE_UUID'") | .text' | sed "s:$TVHEADEND_CCTV_NETWORK_NAME/$PLAYLISTS_CCTV_LOCAL_M3U_FILE - ::g"| cut -d / -f2-)
# Extract channel number from CCTV playlist
CHANNEL_NUMBER=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_CCTV_LOCAL_M3U_FILE} | grep '#EXTINF' | cut -d = -f5 | awk {'print $1'} | sed 's:"::g' | head -1)
CHANNEL_LOGO=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_CCTV_LOCAL_M3U_FILE} | grep '#EXTINF' | cut -d = -f4 | awk {'print $1'} | sed 's:"::g' | head -1)
CHANNEL_CATEGORY=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_CCTV_LOCAL_M3U_FILE} | grep '#EXTINF' | cut -d , -f1 | awk {'print $NF'} | cut -d = -f2 | sed 's:"::g' | head -1)
CHANNEL_TAG=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/list?limit=100000 | jq -r '.entries[] | select(.val=="'${CHANNEL_CATEGORY}'") | .key')
#
# Check if channel already exists
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[]' | grep "$SERVICE_UUID" > /dev/null 2>&1
CHANNEL_EXISTS=$?
#
# Don't add if channel already exists
[ "$CHANNEL_EXISTS" = "0" ] && continue

# Play service URL using ffprobe i.e. Activate it to make it usable as a channel
SERVICE_URL="$TVHEADEND_PLAY_STREAM_URL/service/$SERVICE_UUID"

# Probe remote stream using ffprobe i.e. play mux briefly to add service
$FFPROBE_CMD $FFPROBE_OPTS $SERVICE_URL 2>&1 | tee -a $TVHEADEND_CCTV_INFO_LOG_FILE 

# Add cctv channel creation command to temp file
cat >> $TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE <<EOF
# $CHANNEL_NAME
# -------------
# Add channel to TVHeadend backend
$CURL_CMD $CURL_OPTS -d "\$(printf $(echo -n $(cat <<EOT
conf='{
	"enabled": true,
	"number": $CHANNEL_NUMBER,
	"icon": "file://$PROJECT_SYSTEM_ICONS_DIR/CCTV/$CHANNEL_LOGO",
	"epgauto": true,
	"dvr_pre_time": 0,
	"dvr_pst_time": 0,
	"epg_running": -1,
	"services": [
		"$SERVICE_UUID"
	],
	"tags": [
		"$CHANNEL_TAG"
	],
	"bouquet": ""
}'
EOT
)
))" $TVHEADEND_API_URL/channel/create > /dev/null 2>&1
#
# Notify - Channel added
logger -s -t $(basename $0) "Added Channel No.[$CHANNEL_NUMBER] [$CHANNEL_NAME]"

EOF

done

# Create CCTV channels script
if [[ -e $TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE ]];
then
# Prepare create CCTV channels script
sed -i '1i #!/bin/sh' "$TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE"
chmod 755 $TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE
# Run script to create CCTV channels
$TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE
# Pause for a bit to allow CCTV channels to be added properly
# IMPORTANT: If left out, channels will not be mapped to services
sleep 3
# Remove temp script file
rm -f $TVHEADEND_CCTV_CREATE_CHAN_TEMP_FILE
fi

# Notify of CCTV network mapping complete
# Source notification strings
set_notifications
# Print notifciation to stdout and systemd journal 
print_notification "$CCTV_CHANNEL_MAP_COMPLETED_MESSAGE" text
# Print notification using OSD tool
print_notification "$CCTV_CHANNEL_MAP_COMPLETED_MESSAGE" osd
}


# Group functions
# ---------------
dvb_functions_task_all () {
	tvheadend_dvbt_configure
	zap_dead_services
	dvb_scan_add_muxes
	dvb_add_channel_tags
	dvb_map_services_2_channels
	dvb_refresh_epg_data
	refresh_tvh_kodi_icons
	notify_tv_server_controller_completed
}

iptv_functions_task_all () {
	iptv_get_fresh_playlist
	iptv_scan_add_services
	iptv_add_channel_tags
	iptv_map_services_2_channels
	iptv_refresh_epg_data
	refresh_tvh_kodi_icons
	notify_tv_server_controller_completed
}

cctv_functions_task_all () {
	cctv_scan_add_muxes
	cctv_add_channel_tags
	cctv_map_services_2_channels
}



#################
#  MAIN SCRIPT  #
#################
# Usage - all
usage

# Generate debug log for this tool runs
[[ "$DEBUG_LOG" = "yes" ]] && generate_debug_log

# Run tasks based on type specified
case $TV_TYPE in
dvb)
# Usage - dvb
usage_and_pre_start_dvb

# Scan
[[ "$TV_TASK" = "scan" ]] && \
	tvheadend_dvbt_configure && \
	zap_dead_services && \
	dvb_scan_add_muxes

# Map
[[ "$TV_TASK" = "map" ]] && \
	dvb_add_channel_tags && \
	dvb_map_services_2_channels

# Refresh epg if requested
[[ "$TV_TASK" = "epg" ]] && \
	dvb_refresh_epg_data 

# Refresh TV icons
[[ "$TV_TASK" = "icons" ]] && \
	refresh_tvh_kodi_icons

# All tasks {scan+map} 
[[ "$TV_TASK" = "all" ]] && \
	dvb_functions_task_all

# Repair damaged DVB-T/T2
[[ "$TV_TASK" = "repair" ]] && \
	check_health_of_dvb_tvheadend_network && \
	refresh_tvh_kodi_icons
;;

iptv)
# Usage - iptv
usage_and_pre_start_iptv

# Check for Internet connectivity if not mapping
[[ "$TV_TASK" != "map" ]] && \
	check_internet_connectivity_ping 1

# Fetch fresh playlist if m3u is requested
[[ "$TV_TASK" = "m3u" ]] && \
	iptv_get_fresh_playlist

# Add IPTV Network (except for m3u, epg, icons)
[[ "$TV_TASK" = "m3u" || "$TV_TASK" = "epg" || "$TV_TASK" = "icons" ]] || \
	configure_iptv_network

# Add Services i.e. Manually play each mux found
[[ "$TV_TASK" = "scan" ]] && \
	iptv_scan_add_services

# Map
[[ "$TV_TASK" = "map" ]] && \
	iptv_add_channel_tags && \
	iptv_map_services_2_channels

# Download and refresh epg if requested
[[ "$TV_TASK" = "epg" ]] && \
	iptv_refresh_epg_data

# Refresh TV icons
[[ "$TV_TASK" = "icons" ]] && \
	refresh_tvh_kodi_icons

# All tasks {m3u+scan+map+epg} 
[[ "$TV_TASK" = "all" ]] && \
	iptv_functions_task_all
;;

cctv)
# Usage - cctv
usage_and_pre_start_cctv

# Add CCTV network
configure_cctv_network

# Scan
[[ "$TV_TASK" = "scan" ]] && \
	cctv_scan_add_muxes 

# Map
[[ "$TV_TASK" = "map" ]] && \
	cctv_add_channel_tags && \
	cctv_map_services_2_channels

# All tasks {scan+map} 
[[ "$TV_TASK" = "all" ]] && \
	cctv_functions_task_all
;;

esac

post_config
