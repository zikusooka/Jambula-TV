#!/bin/sh
# This script is used to create DVB-T and IPTV channels in TVHeadend using CLI.
# Use it after services for both have been generated
# Also used in forcing IPTV network to scan from the command line
# Jambula Labs @copyright 2018-2019 All rights reserved

# Variables
PROJECT_NAME=JambulaTV
PROJECT_SYSTEM_CONF_DIR=/etc/$PROJECT_NAME
PROJECT_FUNCTIONS_FILE=$PROJECT_SYSTEM_CONF_DIR/functions
PROJECT_DVBT_SETTINGS_FILE=$PROJECT_SYSTEM_CONF_DIR/dvbt-settings.cfg

# Source install functions
. $PROJECT_FUNCTIONS_FILE

# Source DVBT settings file
. $PROJECT_DVBT_SETTINGS_FILE

# Other variables
TIMEOUT_PROBE="80s"
TIMEOUT_CMD="/usr/bin/timeout $TIMEOUT_PROBE"
FFPROBE_CMD="$TIMEOUT_CMD /usr/bin/ffprobe"
FFPROBE_OPTS="-hide_banner"
YOUTUBE_CMD="/usr/bin/jambulatv-youtube"
YOUTUBE_VARIABLES_TEMP_FILE=$(grep ^YOUTUBE_VARIABLES_TEMP_FILE $YOUTUBE_CMD | cut -d '=' -f2 | head -1 | awk {'print $1'} | sed 's/"//g')

# Email
EMAIL_ADDRESS_USER=$(grep -i EMAIL_TO_ADDRESS $EMAIL_CREDENTIALS_CONFIG | sed '/^#/d' | cut -d = -f2 | sed 's/"//g')

# Product serial number
SERIAL=$(grep -i Serial $PROJECT_RELEASE_FILE | cut -d : -f2)

# TVHeadend
TVHEADEND_DVBT_TUNER_NODE=/dev/dvb/adapter$DVBT_TUNER_NO
TVHEADEND_API_URL="http://${TVHEADEND_HTTP_IP}:${TVHEADEND_HTTP_PORT}/api"
TVHEADEND_PLAY_STREAM_URL="http://${TVHEADEND_HTTP_IP}:${TVHEADEND_HTTP_PORT}/play/stream"
TVHEADEND_IPTV_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") | .uuid')
TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE=/tmp/iptv_service_uuid.txt
TVHEADEND_IPTV_FULL_LOG_FILE=$TVHEADEND_IPTV_LOG_DIR/iptv-scan-full.$(date +%Y%m%d%H%M).log
TVHEADEND_IPTV_FAILED_LOG_FILE=$TVHEADEND_IPTV_LOG_DIR/iptv-scan-error.$(date +%Y%m%d%H%M).log
TVHEADEND_IPTV_SERVICE_LOG_FILE=/tmp/iptv_service_output.log
TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE=/tmp/iptv_scanning_in_progress
TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE=/tmp/iptv_mapping_in_progress
#
TVHEADEND_CAMERAS_FULL_LOG_FILE=$TVHEADEND_IPTV_LOG_DIR/cameras-scan-full.$(date +%Y%m%d%H%M).log
TVHEADEND_CAMERAS_NETWORK_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_CAMERAS_NETWORK_NAME"'") | .uuid')
TVHEADEND_CAMERAS_SERVICE_UUIDS_RAW_FILE=/tmp/cameras_service_uuid.txt

PLAYLISTS_PORT=MY_PLAYLISTS_PORT

IPTV_BUILDER_BASE_DIR=/opt/jambula-iptv-builder
IPTV_BUILDER_GROUPS_DIR=$IPTV_BUILDER_BASE_DIR/groups

TV_TYPE=$1
TV_TASK=$2
# Full, or Incremental scan
if [ "x$3" = "x" ];
then
TV_MEASURE="incremental"
else
TV_MEASURE=$3
fi

# Generate log file
DEBUG_LOG=no


#############
#  NOTICES  #
#############
OSD_NOTICE_NO_TUNER="Unable to detect the TV Tuner. This is most likely a hardware issue.  Please check your DVB-T2 tuner and ensure it is properly connected"
OSD_NOTICE_NO_NETWORK="Your Live TV network and channels list is corrupted. Please wait while I attempt to repair it now"
OSD_NOTICE_NETWORK_NOT_MATCHED="The Live TV network is not associated to your DVB-T/T2 tuner. I will attempt to repair it now, please be patient"
OSD_NOTICE_REPAIR_STARTED="DVB-T/T2 Repair mode started ..."
OSD_NOTICE_REPAIR_NETWORK="Restoring DVB-T/T2 network ..."
OSD_NOTICE_ADD_NETWORK="Setting up a fresh DVB-T/T2 network"
OSD_NOTICE_EXISTING_DVBT_NETWORK="DVB-T/T2 network already exists, proceeding"
OSD_NOTICE_EXISTING_IPTV_NETWORK="IPTV network already exists, proceeding"
OSD_NOTICE_EXISTING_CAMERA_NETWORK="Camera network already exists, proceeding"
OSD_NOTICE_SCAN_NETWORK_STARTED="Scanning of $1 network started. This will take some time, please be patient ..."
OSD_NOTICE_MAP_STARTED_DVBT="Mapping of your DVB-T/T2 network started"
OSD_NOTICE_MAP_STARTED_IPTV="Mapping of your IPTV network started. Please be patient while mapping of your IPTV channels takes place ..."
OSD_NOTICE_MAP_STARTED_CAMERA="Mapping of your CCTV network started. Please be patient while mapping of your Camera channel feeds takes place ..."
OSD_NOTICE_MAP_COMPLETED_DVBT="Mapping of your DVB-T/T2 network completed. You may now resume watching Live TV ..."
OSD_NOTICE_MAP_COMPLETED_IPTV="Mapping of your IPTV network completed. You may now resume watching IPTV ..."
OSD_NOTICE_MAP_COMPLETED_CAMERA="Mapping of your CCTV network completed. You may now resume watching Camera feeds ..."



###############
#  FUNCTIONS  #
###############
usage () {
# Device Name
if [ "x$TV_TYPE" = "x" ];
then
clear
echo "Usage:  ./`basename $0` [dvb|iptv|cameras]
"
exit 1
fi
}

usage_dvb () {
if [ "x$TV_TASK" = "x" ];
then
clear
echo "Usage:  ./`basename $0` dvb [scan|map|all|repair]
"
exit 1
fi
}

usage_iptv () {
if [ "x$TV_TASK" = "x" ];
then
clear
echo "Usage:  ./`basename $0` iptv [get|scan|map|all] [full|incremental]
"
exit 1
fi
}

usage_cameras () {
if [ "x$TV_TASK" = "x" ];
then
clear
echo "Usage:  ./`basename $0` cameras [scan|map|all]
"
exit 1
fi
}

generate_debug_log () {
PARENT_COMMAND="$(ps -o comm= $PPID)"
cat >> $PROJECT_SYSTEM_LOG_DIR/$(basename $0).log <<EOT

$(date +'%b %d %I:%M:%S') [$PARENT_COMMAND] Running '$(basename $0) $TV_TYPE $TV_TASK $TV_MEASURE'
-----------------------------------------------------------------------------------------
EOT
# Start Logging
exec 2>> $PROJECT_SYSTEM_LOG_DIR/$(basename $0).log
}

check_if_in_use () {
CURRENT_PROFILES=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/status/subscriptions | jq '.entries[] | .profile' | sed 's:null::g')
CURRENT_CHANNELS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/status/subscriptions | jq '.entries[] | .channel' | sed 's:null::g')
#
# Quit if TVH Server is being used i.e. Playing TV
if [ "x$CURRENT_CHANNELS" != "x" ] || [ "x$CURRENT_PROFILES" != "x" ];
then
logger -s -t $(basename $0) "The TV Server is currently in use, please pick another convenient time to perform this task"
$OSD_SCRIPT -m "The TV Server is currently in use, please pick another convenient time to perform this task" > /dev/null 2>&1 &
exit 1
fi
}

log_file () {
# Create IPTV log directory if non existent
[ -d $TVHEADEND_IPTV_LOG_DIR ] || mkdir -p $TVHEADEND_IPTV_LOG_DIR
# Give it Multimedia user's permissions
chown -R $MULTIMEDIA_USER:$MULTIMEDIA_USER $TVHEADEND_IPTV_LOG_DIR
# Date stamp log file
cat >> $TVHEADEND_IPTV_FULL_LOG_FILE <<EOT

###############################################################################
IPTV [$TV_MEASURE] services scan performed on:  $(date)
###############################################################################

EOT
}

refresh_tvheadend () {
# Probably better to use TVH API for this, so we dont stop completely
# Restart TVHeadend
sudo systemctl restart tvheadend.service
}

pre_config () {
# Create channels directory, if non-existent
[ -d $TVHEADEND_CHANNELS_CONFIG_DIR ] || mkdir -p $TVHEADEND_CHANNELS_CONFIG_DIR
# Create tags directory, if non-existent
[ -d $TVHEADEND_CHANNELS_TAGS_DIR ] || mkdir -p $TVHEADEND_CHANNELS_TAGS_DIR
#
# Load IPTV Lists i.e. refresh tvheadend
refresh_tvheadend
}

post_config () {
# Give multimedia user permission to access tvheadend directories
chown -R $MULTIMEDIA_USER:video $TVHEADEND_CONFIG_DIR
#
# Refresh tvheadend
refresh_tvheadend
}

scan_osd_notice_started () {
# Display notice
$OSD_SCRIPT -m "$OSD_NOTICE_SCAN_NETWORK_STARTED" > /dev/null 2>&1 &
}

map_osd_notice_started () {
# Display notice
case $TV_TYPE in
dvb)
$OSD_SCRIPT -m "$OSD_NOTICE_MAP_STARTED_DVBT" > /dev/null 2>&1 &
;;
iptv)
$OSD_SCRIPT -m "$OSD_NOTICE_MAP_STARTED_IPTV" > /dev/null 2>&1 &
;;
cameras)
$OSD_SCRIPT -m "$OSD_NOTICE_MAP_STARTED_CAMERA" > /dev/null 2>&1 &
;;
esac
}

map_osd_notice_completed () {
case $TV_TYPE in
dvb)
$OSD_SCRIPT -m "$OSD_NOTICE_MAP_COMPLETED_DVBT" > /dev/null 2>&1 &
;;
iptv)
$OSD_SCRIPT -m "$OSD_NOTICE_MAP_COMPLETED_IPTV" > /dev/null 2>&1 &
;;
cameras)
$OSD_SCRIPT -m "$OSD_NOTICE_MAP_COMPLETED_CAMERA" > /dev/null 2>&1 &
;;
esac
}

email_failed_iptv_notice () {
# Email notice regarding failed IPTV streams
[ -e "$TVHEADEND_IPTV_FAILED_LOG_FILE" ] && \
	$EMAIL_VIA_GMAIL_CMD $EMAIL_ADDRESS_ERRORS "[JambulaTV]: IPTV services failed" "The following IPTV streams are no longer working at the following JambulaTV user: Serial No. $SERIAL" $TVHEADEND_IPTV_FAILED_LOG_FILE
}

zap_dead_services () { 
# Find dead services and remove them 
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/removeunseen 
}

zap_dead_channels () { 
# Find dead channels and remove them before mapping
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq '.entries[] | select(.name | contains("name-not-set")).uuid' | sed 's:"::g' | while read DEAD_CHANNEL_UUID
do
rm -f $TVHEADEND_CHANNELS_CONFIG_DIR/$DEAD_CHANNEL_UUID
done

# Remove previously added channels that no longer have services associated to them i.e. Don't play anymore. 
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq -r '.entries[] |.name,.services,.uuid' | grep -A1 "\[\]" | grep -Ev "(--|\[\])" | while read DEAD_CHANNEL_UUID
do
rm -f $TVHEADEND_CHANNELS_CONFIG_DIR/$DEAD_CHANNEL_UUID
done

# Refresh TVH
refresh_tvheadend
}

get_tvheadend_last_channel_number () {
TVHEADEND_LAST_CHANNEL_NUMBER=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq '.entries[] | select(.name!="name-not-set") | .number'| sort -n | tail -1)
}


############
#  DVB-T2  #
############
configure_dvb_network () {
# Get number of existing DVB networks
ls $TVHEADEND_NETWORK_CONFIG_DIR/*/config > /dev/null 2>&1
DVB_NETWORK_EXISTS=$?
if [ "$DVB_NETWORK_EXISTS" = "0" ];
then
NUMBER_OF_DVB_NETWORKS=$(ls -x $TVHEADEND_NETWORK_CONFIG_DIR/*/config | wc -l)
else
NUMBER_OF_DVB_NETWORKS=0
fi
#
# See if DVB network is corrupted
if [[ -d $TVHEADEND_NETWORK_CONFIG_DIR ]];
then
find $TVHEADEND_NETWORK_CONFIG_DIR -size 0 -type f -exec ls {} \; | grep config > /dev/null 2>&1
DVB_NETWORK_CORRUPTED=$?
else
DVB_NETWORK_CORRUPTED=255
fi

if [ "$DVB_NETWORK_CORRUPTED" = "0" ];
then
# Notify of network restoration
logger -s -t $(basename $0) "$OSD_NOTICE_REPAIR_NETWORK"
#
# Get corrupted DVB network config file
TVHEADEND_NETWORK_CONFIG_FILE=$(find $TVHEADEND_NETWORK_CONFIG_DIR -size 0 -type f -exec ls {} \; | grep config)
# Add network
dvb_tvheadend_network_add

elif [ "$NUMBER_OF_DVB_NETWORKS" = "0" ];
then
# Notify of fresh network addition
logger -s -t $(basename $0) "$OSD_NOTICE_ADD_NETWORK"
#
# Set fresh DVB network config file
TVHEADEND_NETWORK_UUID=$(uuidgen -t | sed 's:-::g')
TVHEADEND_NETWORK_CONFIG_FILE=$TVHEADEND_NETWORK_CONFIG_DIR/$TVHEADEND_NETWORK_UUID/config
# Add network
dvb_tvheadend_network_add

else
# Notify of network already exists and proceeding
logger -s -t $(basename $0) "$OSD_NOTICE_EXISTING_NETWORK"
break

fi
}

dvb_scan_4_services () {
echo
}

dvb_add_channel_tags () {
for TAG_NAME in "Free-To-Air" "Local" "$DVBT_NETWORK_NAME"
do

TAG_UUID=$(uuidgen -t | sed 's:-::g')
TAG_EXISTS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq '.entries[] | select(.name=="'$TAG_NAME'") |.enabled' | sed 's:"::g' | head -1)
TAG_EXISTS_COUNT=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'$TAG_NAME'") |.enabled' | wc -l)
#
# Refresh tvheadend
refresh_tvheadend
#
# Test for existence of channel tag and ensure no duplicates are created
if [[ "$TAG_EXISTS" != "true" || "$TAG_EXISTS_COUNT" = "0" ]];
then
# Create channel tag(s)
cat > $TVHEADEND_CHANNELS_TAGS_DIR/$TAG_UUID <<EOF
{
	"enabled": true,
	"index": 0,
	"name": "$TAG_NAME",
	"internal": false,
	"private": false,
	"icon": "",
	"titled_icon": false,
	"comment": "DVB-T2 $TAG_NAME Channels"
}
EOF
fi

done
}

dvb_map_services_2_channels () {
# OSD notify of map started
map_osd_notice_started $TVHEADEND_IPTV_NETWORK_NAME

# Remove dead channels
zap_dead_channels
# Remove dead services
zap_dead_services
#
# Set starting channel number/digit
get_tvheadend_last_channel_number
let "TVHEADEND_DVB_FIRST_CHANNEL_NUMBER = $TVHEADEND_LAST_CHANNEL_NUMBER + 1"
DIGIT=$TVHEADEND_DVB_FIRST_CHANNEL_NUMBER
#
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq .entries[] | grep "text\": \"$DVBT_NETWORK_NAME" | cut -d '/' -f3 | sed 's:["|,]::g' | sed 's:---::g' | grep -wEv TEST | grep -wEv '{PMT:0}' | sort -u | while read LINE
do
CHANNEL_NUMBER=$DIGIT
CHANNEL_NAME=$LINE
CHANNEL_LOGO=$(echo $CHANNEL_NAME | tr [:lower:] [:upper:]| sed 's: :_:g').png
CHANNEL_UUID=$(uuidgen -t | sed 's:-::g')
#
SERVICE_UUID=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq .entries[] | grep -A2 "text\": \"$DVBT_NETWORK_NAME" | grep -w -A2 "$CHANNEL_NAME" | grep uuid | awk {'print $2'} | head -1 | sed 's:"::g')

# Check if channel already exists
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq '.entries[]' | grep "$SERVICE_UUID" > /dev/null 2>&1
CHANNEL_EXISTS=$?
# Don't add if channel already exists
[ "$CHANNEL_EXISTS" = "0" ] && break

# Create channel config file
cat > $TVHEADEND_CHANNELS_CONFIG_DIR/$CHANNEL_UUID <<EOF
{
	"enabled": true,
	"number": $CHANNEL_NUMBER,
	"icon": "file://$PROJECT_SYSTEM_SHARE_DIR/picons/$TV_MARKET/$CHANNEL_LOGO",
	"epgauto": true,
	"dvr_pre_time": 0,
	"dvr_pst_time": 0,
	"epg_running": -1,
	"services": [
		"$SERVICE_UUID"
	],
	"tags": [
		"",
		""
	],
	"bouquet": ""
}
EOF
#
let "DIGIT = $CHANNEL_NUMBER + 1"
done

# OSD notify of map completion
map_osd_notice_completed $TVHEADEND_IPTV_NETWORK_NAME
}

dvb_tvheadend_network_repair () {
# Quit if TVHeadend is NOT running because of other process like cameras being configured
systemctl -q is-active tvheadend.service || exit

# Notify start of repair process
logger -s -t $(basename $0) "$OSD_NOTICE_REPAIR_STARTED"

# See if DVBT network UUID exists
TVHEADEND_DVBT_NETWORK_UUID=$(curl -s http://127.0.0.1:9981/api/mpegts/network/grid?limit=100000 | jq '.entries[] | select(.networkname=="'"$DVBT_NETWORK_NAME"'") |.uuid' | sed 's:"::g')

# 1) If no DVB-T2 tuner was found
# -------------------------------
if [[ ! -e "$TVHEADEND_DVBT_TUNER_NODE" ]];
then
# OSD notice
sudo $OSD_SCRIPT -m "$OSD_NOTICE_NO_TUNER"
# Journal & CLI notice
logger -s -t $(basename $0) "$OSD_NOTICE_NO_TUNER"
#
# Quit
exit 0
fi

# 2) If DVBT Network was accidentally wiped out
# ---------------------------------------------
if [[ "x$TVHEADEND_DVBT_NETWORK_UUID" = "x" ]];
then
# OSD notice
sudo $OSD_SCRIPT -m "$OSD_NOTICE_NO_NETWORK"
# Journal & CLI notice
logger -s -t $(basename $0) "$OSD_NOTICE_NO_NETWORK"
#
# Restore DVB-T network i.e. Repair 
sudo $(basename $0) dvb all
fi

# 3) If Network added, check if DVB network is correctly associated with the DVB-T2 tuner adapter
# ------------------------------------------------------------------------------------------------
if [[ "x$TVHEADEND_DVBT_NETWORK_UUID" != "x" ]];
then

sudo grep -rli $TVHEADEND_DVBT_NETWORK_UUID $TVHEADEND_ADAPTERS_CONFIG_DIR > /dev/null 2>&1
DVBT_NETWORK_MATCHED_WITH_TUNER=$?

while [[ "$DVBT_NETWORK_MATCHED_WITH_TUNER" != "0" ]];
do
# Journal & CLI notice
logger -s -t $(basename $0) "$OSD_NOTICE_NETWORK_NOT_MATCHED"
 
# Refresh tvheadend
refresh_tvheadend

TVHEADEND_ADAPTERS_CONFIG_FILE=$(sudo grep -rli "$DVBT_TUNER_NAME" $TVHEADEND_ADAPTERS_CONFIG_DIR | sudo xargs grep -l adapter${DVBT_TUNER_NO})
BAD_DVBT_NETWORK_UUID=$(sudo grep -A1 -i "\"networks\": \[" $TVHEADEND_ADAPTERS_CONFIG_FILE | tail -1 | awk {'print $1'} | sed "s:\"::g" | sed "s:\]::g" | sed "s:,::g")
#
# Replace bad DVBT network UUID with current working one
if [[ "x$BAD_DVBT_NETWORK_UUID" != "x" ]];
then
sudo sed -i "s:$BAD_DVBT_NETWORK_UUID:$TVHEADEND_DVBT_NETWORK_UUID:g" $TVHEADEND_ADAPTERS_CONFIG_FILE
else
# Replace blank/missing DVBT network UUID with current working one
sudo sed -i "/\"networks\": \[/a \"$TVHEADEND_DVBT_NETWORK_UUID\"" $TVHEADEND_ADAPTERS_CONFIG_FILE
fi
#
sudo grep -rli $TVHEADEND_DVBT_NETWORK_UUID $TVHEADEND_ADAPTERS_CONFIG_DIR > /dev/null 2>&1
DVBT_NETWORK_MATCHED_WITH_TUNER=$?
done

fi
}


##########
#  IPTV  #
##########
#
iptv_get_fresh_playlist () {
# Fetch fresh IPTV playlists file from remote FTP server
ftp_connect_get_file $(basename $JAMBULATV_FTP_SERVER_IPTV_DIR_NAME)/ $PLAYLISTS_IPTV_WORLD_M3U_FILE $TMPDIR/
#
# Add fresh IPTV m3u8 file to JambulaTV playlists directory
[ -s $TMPDIR/$PLAYLISTS_IPTV_WORLD_M3U_FILE ] && \
	rsync -qavz --delay-updates $TMPDIR/$PLAYLISTS_IPTV_WORLD_M3U_FILE $PLAYLISTS_DIRECTORY/
# Remove temp IPTV playlist file
[ -e $TMPDIR/$PLAYLISTS_IPTV_WORLD_M3U_FILE ] && rm -f $TMPDIR/$PLAYLISTS_IPTV_WORLD_M3U_FILE
}

iptv_scan_add_muxes () {
# Force scan of IPTV network
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/scan -d uuid=$TVHEADEND_IPTV_NETWORK_UUID > /dev/null 2>&1
}

configure_iptv_network () {
# See IPTV network similar to what we want already exists
SIMILAR_IPTV_NETWORK_FOUND=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_IPTV_NETWORK_NAME"'") |.networkname')
#
# Test for existing IPTV network
if [[ "x$TVHEADEND_IPTV_NETWORK_UUID" != "x" || "x$SIMILAR_IPTV_NETWORK_FOUND" != "x" ]];
then
# Notify of IPTV network already existing and proceed
logger -s -t $(basename $0) "$TVHEADEND_IPTV_NETWORK_NAME $OSD_NOTICE_EXISTING_IPTV_NETWORK"

else
# Since this is new setup, generate UUID
TVHEADEND_IPTV_NETWORK_UUID=$(uuidgen -t | sed 's:-::g')
#
# Add IPTV network
iptv_tvheadend_network_add
fi

# Add Muxes i.e. Force scan
iptv_scan_add_muxes 
}

iptv_test_stream () {
# Stream variables
MUX_URL="$TVHEADEND_PLAY_STREAM_URL/mux/$MUX_UUID"
PLAYLIST_URL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq '.entries[] | select(.uuid=="'$MUX_UUID'") | .iptv_url' | sed 's:"::g')
PLAYLIST_CATEGORY=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq '.entries[] | select(.uuid=="'$MUX_UUID'") | .iptv_tags' | sed 's:"::g' | head -1)
PLAYLIST_CHANNEL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq '.entries[] | select(.uuid=="'$MUX_UUID'") | .iptv_sname' | sed 's:"::g' | head -1)
PLAYLIST_PIPE_COMMAND="$(echo $PLAYLIST_URL | sed 's|pipe://||g')"

# Add to log file
echo 2>&1 | tee -a $TVHEADEND_IPTV_FULL_LOG_FILE << EOF


*******************************************************************************
JambulaTV: Testing IPTV stream: [$SERVICE_NAME], please wait ...
*******************************************************************************

EOF
# Probe remote stream using ffprobe i.e. play mux briefly to add service
$FFPROBE_CMD $FFPROBE_OPTS $MUX_URL 2>&1 | tee -a $TVHEADEND_IPTV_FULL_LOG_FILE > $TVHEADEND_IPTV_SERVICE_LOG_FILE

# Check if service was added i.e. Remote Link works
SERVICE_ADDED=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .num_svc' | sed 's:"::g')

# Test for whether stream was working
if [ "$SERVICE_ADDED" != "1" ];
then
# Log failed streams
cat >> $TVHEADEND_IPTV_FAILED_LOG_FILE << STREAMLOG

*******************************************************************************
$PLAYLIST_CHANNEL ($PLAYLIST_CATEGORY)
*******************************************************************************

Link:	$PLAYLIST_URL

Error:	$(cat $TVHEADEND_IPTV_SERVICE_LOG_FILE)

STREAMLOG
fi
}

iptv_scan_add_services () {
# timestamp log file
log_file
#
# Add control file for other apps to know that IPTV scan is in progress
[ -e $TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE ] || touch $TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE
#
# Remove dead services
zap_dead_services
#
# OSD notify of scan
scan_osd_notice_started $TVHEADEND_IPTV_NETWORK_NAME
#
# ----------------------------------------------------------
# Cycle through all IPTV MUX IDs and test to create services
# ----------------------------------------------------------
#
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq '.entries[] | select(.network_uuid=="'"$TVHEADEND_IPTV_NETWORK_UUID"'") | .uuid' | sed 's:"::g' | while read MUX_UUID

do
# Do not play if we already have a service
SERVICE_ADDED=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .num_svc' | sed 's:"::g')
SERVICE_NAME=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq '.entries[] | select(.uuid=="'"$MUX_UUID"'") | .name' | sed 's:"::g' | sed "s:$PLAYLISTS_IPTV_WORLD_M3U_FILE - ::g")
# Pipe stream variables
PLAYLIST_URL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq '.entries[] | select(.uuid=="'$MUX_UUID'") | .iptv_url' | sed 's:"::g')
PLAYLIST_CHANNEL=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/mux/grid?limit=100000 | jq '.entries[] | select(.uuid=="'$MUX_UUID'") | .iptv_sname' | sed 's:"::g' | head -1)
PLAYLIST_PIPE_COMMAND="$(echo $PLAYLIST_URL | sed 's|pipe://||g')"
#
echo $PLAYLIST_URL | grep $PLAYLIST_PIPE_COMMAND > /dev/null 2>&1
IS_YPIPE=$?

# Test stream i.e. create service depending on whether full or incremental is specified
case $1 in

incremental)
# Add service if none existent (i.e. play mux).  Force testing of Youtube pipes
# .............................................................................
# SERVICE_ADDED=1 means service was found
# IS_YPIPE=0 means URL is a Youtube pipe
if [[ "$SERVICE_ADDED" != "1" || "$IS_YPIPE" = "0" ]];
then
iptv_test_stream
fi
;;

full)
# Play mux i.e. Add service regardless of existence of service
iptv_test_stream
;;

*)
# Assume this is incremental:
# Add service if none existent (i.e. play mux).  Force testing of Youtube pipes
# .............................................................................
# SERVICE_ADDED=1 means service was found
# IS_YPIPE=0 means URL is a Youtube pipe
if [[ "$SERVICE_ADDED" != "1" || "$IS_YPIPE" = "0" ]];
then
iptv_test_stream
fi
;;
esac

done
#
# Email failed IPTV streams
email_failed_iptv_notice
#
# Remove control file for other apps to know that IPTV scan completed
[ -e $TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE ] && sudo rm -f $TVHEADEND_IPTV_SCAN_IN_PROGRESS_TEMP_FILE
}

get_channel_number_using_iptv_builder () {
#
# Variables
CHANNEL_NUMBER_TEMP_FILE=/tmp/chan_number
CHANNEL_COUNT=$(grep -iEw "${CHANNEL_NAME}" -d skip $IPTV_BUILDER_GROUPS_DIR/* | cut -d '|' -f2 | sed 's: ::g' | wc -l)
# Remove existing file
[ -e $CHANNEL_NUMBER_TEMP_FILE ] && rm -f $CHANNEL_NUMBER_TEMP_FILE
# Find channel number, if more than one match
if [ "$CHANNEL_COUNT" -gt "1" ];
then

grep -iEw "${CHANNEL_NAME}" -d skip $IPTV_BUILDER_GROUPS_DIR/* | while read LINE
do
COL1=$(echo $LINE | cut -d ':' -f2 | cut -d '|' -f1 | sed 's/ $//')
COL2=$(echo $LINE | cut -d ':' -f2 | cut -d '|' -f2 | sed 's/ //g')
if [ "$COL1" = "$CHANNEL_NAME" ];
then
# Set channel number
echo "CHANNEL_NUMBER=$COL2" > $CHANNEL_NUMBER_TEMP_FILE
fi
break
done 

else
# Find channel number, if only one match
CHANNEL_NUMBER=$(grep -iEw "${CHANNEL_NAME}" -d skip $IPTV_BUILDER_GROUPS_DIR/* | cut -d '|' -f2 | sed 's: ::g' | head -1)
fi
# Source temp channel number file i.e. Get channel number
[ -e $CHANNEL_NUMBER_TEMP_FILE ] && . $CHANNEL_NUMBER_TEMP_FILE
# Export
export CHANNEL_NUMBER
}

iptv_map_services_2_channels () {
# Add control file for other apps to know that IPTV map is in progress
[ -e $TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE ] || touch $TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE
#
# OSD notify of map started
map_osd_notice_started $TVHEADEND_IPTV_NETWORK_NAME
#
# Remove dead channels
zap_dead_channels
#
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq '.entries[] | select(.text | contains("'${TVHEADEND_IPTV_NETWORK_NAME}'")).uuid' | sed 's:"::g' > $TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE
cat $TVHEADEND_IPTV_SERVICE_UUIDS_RAW_FILE | while read SERVICE_UUID
do
CHANNEL_NAME=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq '.entries[] | select(.uuid=="'$SERVICE_UUID'") | .text' | sed "s:$TVHEADEND_IPTV_NETWORK_NAME/$PLAYLISTS_IPTV_WORLD_M3U_FILE - ::g"| cut -d / -f2- | sed 's:"::g')
# Extract channel number from iptv group files
get_channel_number_using_iptv_builder
#
CHANNEL_LOGO=$(echo $CHANNEL_NAME | tr [:upper:] [:lower:]| sed 's: :_:g').png
CHANNEL_UUID=$(uuidgen -t | sed 's:-::g')
CHANNEL_CATEGORY=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_IPTV_WORLD_M3U_FILE} | grep '#EXTINF' | cut -d , -f1 | awk {'print $NF'} | cut -d = -f2 | sed 's:"::g' | head -1)
CHANNEL_TAG=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/list?limit=100000 | jq '.entries[] | select(.val=="'${CHANNEL_CATEGORY}'") | .key' | sed 's:"::g')
#
# Check if channel already exists
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq '.entries[]' | grep "$SERVICE_UUID" > /dev/null 2>&1
CHANNEL_EXISTS=$?
#
# Don't add if channel already exists
[ "$CHANNEL_EXISTS" = "0" ] && continue

# Play service URL using ffprobe i.e. Activate it to make it usable as a channel
SERVICE_URL="$TVHEADEND_PLAY_STREAM_URL/service/$SERVICE_UUID"

# Probe remote stream using ffprobe i.e. play mux briefly to add service
$FFPROBE_CMD $FFPROBE_OPTS $SERVICE_URL 2>&1 | tee -a $TVHEADEND_IPTV_FULL_LOG_FILE 

# Create channel config file
cat > $TVHEADEND_CHANNELS_CONFIG_DIR/$CHANNEL_UUID <<EOF
{
	"enabled": true,
	"number": $CHANNEL_NUMBER,
	"icon": "file://$PROJECT_SYSTEM_ICONS_DIR/IPTV/$CHANNEL_LOGO",
	"epgauto": true,
	"dvr_pre_time": 0,
	"dvr_pst_time": 0,
	"epg_running": -1,
	"services": [
		"$SERVICE_UUID"
	],
	"tags": [
		"$CHANNEL_TAG"
	],
	"bouquet": ""
}
EOF

done
#
# OSD notify of map completion
map_osd_notice_completed $TVHEADEND_IPTV_NETWORK_NAME
#
# Remove control file for other apps to know that IPTV map completed
[ -e $TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE ] && sudo rm -f $TVHEADEND_IPTV_MAP_IN_PROGRESS_TEMP_FILE
}

iptv_add_channel_tags () {
cat ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_IPTV_WORLD_M3U_FILE} | grep '#EXTINF' | cut -d , -f1 | awk {'print $NF'} | cut -d = -f2 | sed 's:"::g' | sort -u | while read IPTV_CHANNEL
do

TAG_NAME=$IPTV_CHANNEL 
TAG_UUID=$(uuidgen -t | sed 's:-::g')
TAG_EXISTS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq '.entries[] | select(.name=="'$TAG_NAME'") |.enabled' | sed 's:"::g' | head -1)
TAG_EXISTS_COUNT=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'$TAG_NAME'") |.enabled' | wc -l)
#
# Refresh tvheadend
refresh_tvheadend
#
# Test for existence of channel tag and ensure no duplicates are created
if [[ "$TAG_EXISTS" != "true" || "$TAG_EXISTS_COUNT" = "0" ]];
then
# Create channel tag(s)
cat > $TVHEADEND_CHANNELS_TAGS_DIR/$TAG_UUID <<EOF
{
	"enabled": true,
	"index": 0,
	"name": "$TAG_NAME",
	"internal": false,
	"private": false,
	"icon": "",
	"titled_icon": false,
	"comment": "IPTV $TAG_NAME Channels"
}
EOF
fi

done
}


#############
#  CAMERAS  #
#############
#
configure_cameras_network () {
# See CAMERAS network similar to what we want already exists
SIMILAR_CAMERAS_NETWORK_FOUND=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/grid?limit=100000 | jq -r '.entries[] | select(.networkname=="'"$TVHEADEND_CAMERAS_NETWORK_NAME"'") |.networkname')
#
# Test for existing Cameras network
if [[ "x$TVHEADEND_CAMERAS_NETWORK_UUID" != "x" || "x$SIMILAR_CAMERAS_NETWORK_FOUND" != "x" ]];
then
# Notify of camera network already existing and proceed
logger -s -t $(basename $0) "$TVHEADEND_CAMERAS_NETWORK_NAME $OSD_NOTICE_EXISTING_CAMERA_NETWORK"

else
# Since this is new setup, generate UUID
TVHEADEND_CAMERAS_NETWORK_UUID=$(uuidgen -t | sed 's:-::g')
#
# Add Cameras network
cameras_tvheadend_network_add
fi
}

cameras_scan_add_muxes () {
# Force scan of cameras network
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/mpegts/network/scan -d uuid=$TVHEADEND_CAMERAS_NETWORK_UUID > /dev/null 2>&1
}

cameras_add_channel_tags () {
cat ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_CAMERAS_LOCAL_M3U_FILE} | grep '#EXTINF' | cut -d , -f1 | awk {'print $NF'} | cut -d = -f2 | sed 's:"::g' | sort -u | while read CAMERA_CHANNEL
do
TAG_NAME=$CAMERA_CHANNEL 
TAG_UUID=$(uuidgen -t | sed 's:-::g')
TAG_EXISTS=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq '.entries[] | select(.name=="'$TAG_NAME'") |.enabled' | sed 's:"::g' | head -1)
TAG_EXISTS_COUNT=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/grid?limit=100000 | jq -r '.entries[] | select(.name=="'$TAG_NAME'") |.enabled' | wc -l)
#
# Refresh tvheadend
refresh_tvheadend
#
# Test for existence of channel tag and ensure no duplicates are created
if [[ "$TAG_EXISTS" != "true" || "$TAG_EXISTS_COUNT" = "0" ]];
then
# Create channel tag(s)
cat > $TVHEADEND_CHANNELS_TAGS_DIR/$TAG_UUID <<EOF
{
	"enabled": true,
	"index": 0,
	"name": "$TAG_NAME",
	"internal": false,
	"private": false,
	"icon": "",
	"titled_icon": false,
	"comment": "Web-based $TAG_NAME Channels"
}
EOF
fi

done
}

cameras_map_services_2_channels () {
# OSD notify of map started
map_osd_notice_started $TVHEADEND_CAMERAS_NETWORK_NAME
#
# Remove dead channels
zap_dead_channels
#
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq '.entries[] | select(.text | contains("'${TVHEADEND_CAMERAS_NETWORK_NAME}'")).uuid' | sed 's:"::g' > $TVHEADEND_CAMERAS_SERVICE_UUIDS_RAW_FILE
#
cat $TVHEADEND_CAMERAS_SERVICE_UUIDS_RAW_FILE | while read SERVICE_UUID
do
CHANNEL_NAME=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/service/list?limit=100000 | jq '.entries[] | select(.uuid=="'$SERVICE_UUID'") | .text' | sed "s:$TVHEADEND_CAMERAS_NETWORK_NAME/$PLAYLISTS_CAMERAS_LOCAL_M3U_FILE - ::g"| cut -d / -f2- | sed 's:"::g')
# Extract channel number from cameras playlist
CHANNEL_NUMBER=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_CAMERAS_LOCAL_M3U_FILE} | grep '#EXTINF' | cut -d = -f5 | awk {'print $1'} | sed 's:"::g' | head -1)
CHANNEL_LOGO=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_CAMERAS_LOCAL_M3U_FILE} | grep '#EXTINF' | cut -d = -f4 | awk {'print $1'} | sed 's:"::g' | head -1)
CHANNEL_UUID=$(uuidgen -t | sed 's:-::g')
CHANNEL_CATEGORY=$(grep -Ew "${CHANNEL_NAME}$" ${PLAYLISTS_DIRECTORY}/${PLAYLISTS_CAMERAS_LOCAL_M3U_FILE} | grep '#EXTINF' | cut -d , -f1 | awk {'print $NF'} | cut -d = -f2 | sed 's:"::g' | head -1)
CHANNEL_TAG=$($CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channeltag/list?limit=100000 | jq '.entries[] | select(.val=="'${CHANNEL_CATEGORY}'") | .key' | sed 's:"::g')
#
# Check if channel already exists
$CURL_CMD $CURL_OPTS $TVHEADEND_API_URL/channel/grid?limit=100000 | jq '.entries[]' | grep "$SERVICE_UUID" > /dev/null 2>&1
CHANNEL_EXISTS=$?
#
# Don't add if channel already exists
[ "$CHANNEL_EXISTS" = "0" ] && continue

# Play service URL using ffprobe i.e. Activate it to make it usable as a channel
SERVICE_URL="$TVHEADEND_PLAY_STREAM_URL/service/$SERVICE_UUID"

# Probe remote stream using ffprobe i.e. play mux briefly to add service
$FFPROBE_CMD $FFPROBE_OPTS $SERVICE_URL 2>&1 | tee -a $TVHEADEND_CAMERAS_FULL_LOG_FILE 

# Create channel config file
cat > $TVHEADEND_CHANNELS_CONFIG_DIR/$CHANNEL_UUID <<EOF
{
	"enabled": true,
	"number": $CHANNEL_NUMBER,
	"icon": "file://$PROJECT_SYSTEM_ICONS_DIR/Cameras/$CHANNEL_LOGO",
	"epgauto": true,
	"dvr_pre_time": 0,
	"dvr_pst_time": 0,
	"epg_running": -1,
	"services": [
		"$SERVICE_UUID"
	],
	"tags": [
		"$CHANNEL_TAG"
	],
	"bouquet": ""
}
EOF

done

# OSD notify of map completion
map_osd_notice_completed $TVHEADEND_CAMERAS_NETWORK_NAME
}



#################
#  MAIN SCRIPT  #
#################

# Generate debug log for this tool runs
[[ "$DEBUG_LOG" = "yes" ]] && generate_debug_log

# Check to see if TVHeadend server is in use and when NOT controlling cameras
[[ "$TV_TYPE" != "cameras" ]] && check_if_in_use 

# If IPTV specified, check for Internet connectivity before proceeding
[[ "$TV_TYPE" = "iptv" ]] && check_internet_connectivity_ping 1

# Pre-run checks (if not repairing)
[[ "$TV_TASK" = "repair" ]] || pre_config

# Run tasks based on type specified
case $TV_TYPE in
dvb)
# Usage
usage_dvb

# Add DVB-T2 Network (if not repairing)
[[ "$TV_TASK" = "repair" ]] || configure_dvb_network

# Scan
[[ "$TV_TASK" = "scan" ]] && \
	zap_dead_services && \
	dvb_scan_4_services

# Map
[[ "$TV_TASK" = "map" ]] && \
	dvb_add_channel_tags && \
	dvb_map_services_2_channels

# All tasks {scan+map} 
[[ "$TV_TASK" = "all" ]] && \
	$(basename $0) dvb scan && \
	sleep 45 && \
	$(basename $0) dvb map

# Repair damaged DVB-T/T2
[[ "$TV_TASK" = "repair" ]] && \
	dvb_tvheadend_network_repair
;;

iptv)
# Usage
usage_iptv

# Fetch fresh playlist if get is requested
[[ "$TV_TASK" = "get" ]] && \
	iptv_get_fresh_playlist

# Add IPTV Network
configure_iptv_network

# Add Services i.e. Manually play each mux found
[[ "$TV_TASK" = "scan" && "$TV_MEASURE" = "incremental" ]] && \
	iptv_scan_add_services incremental
[[ "$TV_TASK" = "scan" && "$TV_MEASURE" = "full" ]] && \
	iptv_scan_add_services full
[[ "$TV_TASK" = "scan" && "x$TV_MEASURE" = "x" ]] && \
	iptv_scan_add_services incremental

# Map
[[ "$TV_TASK" = "map" ]] && \
	iptv_add_channel_tags && \
	iptv_map_services_2_channels

# All tasks {get+scan+map} in incremental mode
[[ "$TV_TASK" = "all" && "$TV_MEASURE" = "incremental" || "x$TV_MEASURE" = "x" ]] && \
	$(basename $0) iptv get && \
	$(basename $0) iptv scan incremental && \
	$(basename $0) iptv map

# All tasks {get+scan+map} in full mode 
[[ "$TV_TASK" = "all" && "$TV_MEASURE" = "full" ]] && \
	$(basename $0) iptv get && \
	$(basename $0) iptv scan full && \
	$(basename $0) iptv map
;;

cameras)
# Usage
usage_cameras

# Add cameras network
configure_cameras_network

# Scan - using force method NOTE: restart tvheadend to get same effect i.e. refresh_tvheadend
[[ "$TV_TASK" = "scan" ]] && \
	cameras_scan_add_muxes 

# Map
[[ "$TV_TASK" = "map" ]] && \
	cameras_add_channel_tags && \
	cameras_map_services_2_channels

# All tasks {scan+map} 
[[ "$TV_TASK" = "all" ]] && \
	$(basename $0) cameras scan && \
	$(basename $0) cameras map
;;

*)
usage
;;
esac

post_config
